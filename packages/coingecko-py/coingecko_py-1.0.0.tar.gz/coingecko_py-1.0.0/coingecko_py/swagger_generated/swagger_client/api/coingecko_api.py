# coding: utf-8

"""
    CoinGecko API V3

    No description provided (generated by Swagger Codegen https://github.com/swagger-api/swagger-codegen)  # noqa: E501

    OpenAPI spec version: 3.0.0
    
    Generated by: https://github.com/swagger-api/swagger-codegen.git
"""

from __future__ import absolute_import

import re  # noqa: F401

# python 2 and python 3 compatibility library
import six

from coingecko_py.swagger_generated.swagger_client.api_client import ApiClient


class CoingeckoApi(object):
    """NOTE: This class is auto generated by the swagger code generator program.

    Do not edit the class manually.
    Ref: https://github.com/swagger-api/swagger-codegen
    """

    def __init__(self, api_client=None):
        if api_client is None:
            api_client = ApiClient()
        self.api_client = api_client

    def asset_platforms_get(self, **kwargs):  # noqa: E501
        """List all asset platforms (Blockchain networks)  # noqa: E501

        List all asset platforms  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.asset_platforms_get(async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs["_return_http_data_only"] = True
        if kwargs.get("async_req"):
            return self.asset_platforms_get_with_http_info(**kwargs)  # noqa: E501
        else:
            (data) = self.asset_platforms_get_with_http_info(**kwargs)  # noqa: E501
            return data

    def asset_platforms_get_with_http_info(self, **kwargs):  # noqa: E501
        """List all asset platforms (Blockchain networks)  # noqa: E501

        List all asset platforms  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.asset_platforms_get_with_http_info(async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = []  # noqa: E501
        all_params.append("async_req")
        all_params.append("_return_http_data_only")
        all_params.append("_preload_content")
        all_params.append("_request_timeout")

        params = locals()
        for key, val in six.iteritems(params["kwargs"]):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method asset_platforms_get" % key
                )
            params[key] = val
        del params["kwargs"]

        collection_formats = {}

        path_params = {}

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # Authentication setting
        auth_settings = []  # noqa: E501

        return self.api_client.call_api(
            "/asset_platforms",
            "GET",
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type=None,  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get("async_req"),
            _return_http_data_only=params.get("_return_http_data_only"),
            _preload_content=params.get("_preload_content", True),
            _request_timeout=params.get("_request_timeout"),
            collection_formats=collection_formats,
        )

    def coins_categories_get(self, **kwargs):  # noqa: E501
        """List all categories with market data  # noqa: E501

        List all categories with market data  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.coins_categories_get(async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str order: valid values: <b>market_cap_desc (default), market_cap_asc, name_desc, name_asc, market_cap_change_24h_desc and market_cap_change_24h_asc</b>
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs["_return_http_data_only"] = True
        if kwargs.get("async_req"):
            return self.coins_categories_get_with_http_info(**kwargs)  # noqa: E501
        else:
            (data) = self.coins_categories_get_with_http_info(**kwargs)  # noqa: E501
            return data

    def coins_categories_get_with_http_info(self, **kwargs):  # noqa: E501
        """List all categories with market data  # noqa: E501

        List all categories with market data  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.coins_categories_get_with_http_info(async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str order: valid values: <b>market_cap_desc (default), market_cap_asc, name_desc, name_asc, market_cap_change_24h_desc and market_cap_change_24h_asc</b>
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ["order"]  # noqa: E501
        all_params.append("async_req")
        all_params.append("_return_http_data_only")
        all_params.append("_preload_content")
        all_params.append("_request_timeout")

        params = locals()
        for key, val in six.iteritems(params["kwargs"]):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method coins_categories_get" % key
                )
            params[key] = val
        del params["kwargs"]

        collection_formats = {}

        path_params = {}

        query_params = []
        if "order" in params:
            query_params.append(("order", params["order"]))  # noqa: E501

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # Authentication setting
        auth_settings = []  # noqa: E501

        return self.api_client.call_api(
            "/coins/categories",
            "GET",
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type=None,  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get("async_req"),
            _return_http_data_only=params.get("_return_http_data_only"),
            _preload_content=params.get("_preload_content", True),
            _request_timeout=params.get("_request_timeout"),
            collection_formats=collection_formats,
        )

    def coins_categories_list_get(self, **kwargs):  # noqa: E501
        """List all categories  # noqa: E501

        List all categories  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.coins_categories_list_get(async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs["_return_http_data_only"] = True
        if kwargs.get("async_req"):
            return self.coins_categories_list_get_with_http_info(**kwargs)  # noqa: E501
        else:
            (data) = self.coins_categories_list_get_with_http_info(
                **kwargs
            )  # noqa: E501
            return data

    def coins_categories_list_get_with_http_info(self, **kwargs):  # noqa: E501
        """List all categories  # noqa: E501

        List all categories  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.coins_categories_list_get_with_http_info(async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = []  # noqa: E501
        all_params.append("async_req")
        all_params.append("_return_http_data_only")
        all_params.append("_preload_content")
        all_params.append("_request_timeout")

        params = locals()
        for key, val in six.iteritems(params["kwargs"]):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method coins_categories_list_get" % key
                )
            params[key] = val
        del params["kwargs"]

        collection_formats = {}

        path_params = {}

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # Authentication setting
        auth_settings = []  # noqa: E501

        return self.api_client.call_api(
            "/coins/categories/list",
            "GET",
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type=None,  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get("async_req"),
            _return_http_data_only=params.get("_return_http_data_only"),
            _preload_content=params.get("_preload_content", True),
            _request_timeout=params.get("_request_timeout"),
            collection_formats=collection_formats,
        )

    def coins_id_contract_contract_address_get(
        self, id, contract_address, **kwargs
    ):  # noqa: E501
        """Get coin info from contract address  # noqa: E501

        Get coin info from contract address  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.coins_id_contract_contract_address_get(id, contract_address, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str id: Asset platform (See asset_platforms endpoint for list of options) (required)
        :param str contract_address: Token's contract address (required)
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs["_return_http_data_only"] = True
        if kwargs.get("async_req"):
            return self.coins_id_contract_contract_address_get_with_http_info(
                id, contract_address, **kwargs
            )  # noqa: E501
        else:
            (data) = self.coins_id_contract_contract_address_get_with_http_info(
                id, contract_address, **kwargs
            )  # noqa: E501
            return data

    def coins_id_contract_contract_address_get_with_http_info(
        self, id, contract_address, **kwargs
    ):  # noqa: E501
        """Get coin info from contract address  # noqa: E501

        Get coin info from contract address  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.coins_id_contract_contract_address_get_with_http_info(id, contract_address, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str id: Asset platform (See asset_platforms endpoint for list of options) (required)
        :param str contract_address: Token's contract address (required)
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ["id", "contract_address"]  # noqa: E501
        all_params.append("async_req")
        all_params.append("_return_http_data_only")
        all_params.append("_preload_content")
        all_params.append("_request_timeout")

        params = locals()
        for key, val in six.iteritems(params["kwargs"]):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method coins_id_contract_contract_address_get" % key
                )
            params[key] = val
        del params["kwargs"]
        # verify the required parameter 'id' is set
        if "id" not in params or params["id"] is None:
            raise ValueError(
                "Missing the required parameter `id` when calling `coins_id_contract_contract_address_get`"
            )  # noqa: E501
        # verify the required parameter 'contract_address' is set
        if "contract_address" not in params or params["contract_address"] is None:
            raise ValueError(
                "Missing the required parameter `contract_address` when calling `coins_id_contract_contract_address_get`"
            )  # noqa: E501

        collection_formats = {}

        path_params = {}
        if "id" in params:
            path_params["id"] = params["id"]  # noqa: E501
        if "contract_address" in params:
            path_params["contract_address"] = params["contract_address"]  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # Authentication setting
        auth_settings = []  # noqa: E501

        return self.api_client.call_api(
            "/coins/{id}/contract/{contract_address}",
            "GET",
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type=None,  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get("async_req"),
            _return_http_data_only=params.get("_return_http_data_only"),
            _preload_content=params.get("_preload_content", True),
            _request_timeout=params.get("_request_timeout"),
            collection_formats=collection_formats,
        )

    def coins_id_contract_contract_address_market_chart_get(
        self, id, contract_address, vs_currency, days, **kwargs
    ):  # noqa: E501
        """Get historical market data include price, market cap, and 24h volume (granularity auto) from a contract address   # noqa: E501

        Get historical market data include price, market cap, and 24h volume (granularity auto)   # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.coins_id_contract_contract_address_market_chart_get(id, contract_address, vs_currency, days, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str id: The id of the platform issuing tokens (See asset_platforms endpoint for list of options) (required)
        :param str contract_address: Token's contract address (required)
        :param str vs_currency: The target currency of market data (usd, eur, jpy, etc.) (required)
        :param str days: Data up to number of days ago (eg. 1,14,30,max) (required)
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs["_return_http_data_only"] = True
        if kwargs.get("async_req"):
            return (
                self.coins_id_contract_contract_address_market_chart_get_with_http_info(
                    id, contract_address, vs_currency, days, **kwargs
                )
            )  # noqa: E501
        else:
            (
                data
            ) = self.coins_id_contract_contract_address_market_chart_get_with_http_info(
                id, contract_address, vs_currency, days, **kwargs
            )  # noqa: E501
            return data

    def coins_id_contract_contract_address_market_chart_get_with_http_info(
        self, id, contract_address, vs_currency, days, **kwargs
    ):  # noqa: E501
        """Get historical market data include price, market cap, and 24h volume (granularity auto) from a contract address   # noqa: E501

        Get historical market data include price, market cap, and 24h volume (granularity auto)   # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.coins_id_contract_contract_address_market_chart_get_with_http_info(id, contract_address, vs_currency, days, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str id: The id of the platform issuing tokens (See asset_platforms endpoint for list of options) (required)
        :param str contract_address: Token's contract address (required)
        :param str vs_currency: The target currency of market data (usd, eur, jpy, etc.) (required)
        :param str days: Data up to number of days ago (eg. 1,14,30,max) (required)
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ["id", "contract_address", "vs_currency", "days"]  # noqa: E501
        all_params.append("async_req")
        all_params.append("_return_http_data_only")
        all_params.append("_preload_content")
        all_params.append("_request_timeout")

        params = locals()
        for key, val in six.iteritems(params["kwargs"]):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method coins_id_contract_contract_address_market_chart_get"
                    % key
                )
            params[key] = val
        del params["kwargs"]
        # verify the required parameter 'id' is set
        if "id" not in params or params["id"] is None:
            raise ValueError(
                "Missing the required parameter `id` when calling `coins_id_contract_contract_address_market_chart_get`"
            )  # noqa: E501
        # verify the required parameter 'contract_address' is set
        if "contract_address" not in params or params["contract_address"] is None:
            raise ValueError(
                "Missing the required parameter `contract_address` when calling `coins_id_contract_contract_address_market_chart_get`"
            )  # noqa: E501
        # verify the required parameter 'vs_currency' is set
        if "vs_currency" not in params or params["vs_currency"] is None:
            raise ValueError(
                "Missing the required parameter `vs_currency` when calling `coins_id_contract_contract_address_market_chart_get`"
            )  # noqa: E501
        # verify the required parameter 'days' is set
        if "days" not in params or params["days"] is None:
            raise ValueError(
                "Missing the required parameter `days` when calling `coins_id_contract_contract_address_market_chart_get`"
            )  # noqa: E501

        collection_formats = {}

        path_params = {}
        if "id" in params:
            path_params["id"] = params["id"]  # noqa: E501
        if "contract_address" in params:
            path_params["contract_address"] = params["contract_address"]  # noqa: E501

        query_params = []
        if "vs_currency" in params:
            query_params.append(("vs_currency", params["vs_currency"]))  # noqa: E501
        if "days" in params:
            query_params.append(("days", params["days"]))  # noqa: E501

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # Authentication setting
        auth_settings = []  # noqa: E501

        return self.api_client.call_api(
            "/coins/{id}/contract/{contract_address}/market_chart/",
            "GET",
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type=None,  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get("async_req"),
            _return_http_data_only=params.get("_return_http_data_only"),
            _preload_content=params.get("_preload_content", True),
            _request_timeout=params.get("_request_timeout"),
            collection_formats=collection_formats,
        )

    def coins_id_contract_contract_address_market_chart_range_get(
        self, id, contract_address, vs_currency, _from, to, **kwargs
    ):  # noqa: E501
        """Get historical market data include price, market cap, and 24h volume within a range of timestamp (granularity auto) from a contract address  # noqa: E501

        Get historical market data include price, market cap, and 24h volume within a range of timestamp (granularity auto)   # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.coins_id_contract_contract_address_market_chart_range_get(id, contract_address, vs_currency, _from, to, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str id: The id of the platform issuing tokens (See asset_platforms endpoint for list of options) (required)
        :param str contract_address: Token's contract address (required)
        :param str vs_currency: The target currency of market data (usd, eur, jpy, etc.) (required)
        :param str _from: From date in UNIX Timestamp (eg. 1392577232) (required)
        :param str to: To date in UNIX Timestamp (eg. 1422577232) (required)
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs["_return_http_data_only"] = True
        if kwargs.get("async_req"):
            return self.coins_id_contract_contract_address_market_chart_range_get_with_http_info(
                id, contract_address, vs_currency, _from, to, **kwargs
            )  # noqa: E501
        else:
            (
                data
            ) = self.coins_id_contract_contract_address_market_chart_range_get_with_http_info(
                id, contract_address, vs_currency, _from, to, **kwargs
            )  # noqa: E501
            return data

    def coins_id_contract_contract_address_market_chart_range_get_with_http_info(
        self, id, contract_address, vs_currency, _from, to, **kwargs
    ):  # noqa: E501
        """Get historical market data include price, market cap, and 24h volume within a range of timestamp (granularity auto) from a contract address  # noqa: E501

        Get historical market data include price, market cap, and 24h volume within a range of timestamp (granularity auto)   # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.coins_id_contract_contract_address_market_chart_range_get_with_http_info(id, contract_address, vs_currency, _from, to, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str id: The id of the platform issuing tokens (See asset_platforms endpoint for list of options) (required)
        :param str contract_address: Token's contract address (required)
        :param str vs_currency: The target currency of market data (usd, eur, jpy, etc.) (required)
        :param str _from: From date in UNIX Timestamp (eg. 1392577232) (required)
        :param str to: To date in UNIX Timestamp (eg. 1422577232) (required)
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = [
            "id",
            "contract_address",
            "vs_currency",
            "_from",
            "to",
        ]  # noqa: E501
        all_params.append("async_req")
        all_params.append("_return_http_data_only")
        all_params.append("_preload_content")
        all_params.append("_request_timeout")

        params = locals()
        for key, val in six.iteritems(params["kwargs"]):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method coins_id_contract_contract_address_market_chart_range_get"
                    % key
                )
            params[key] = val
        del params["kwargs"]
        # verify the required parameter 'id' is set
        if "id" not in params or params["id"] is None:
            raise ValueError(
                "Missing the required parameter `id` when calling `coins_id_contract_contract_address_market_chart_range_get`"
            )  # noqa: E501
        # verify the required parameter 'contract_address' is set
        if "contract_address" not in params or params["contract_address"] is None:
            raise ValueError(
                "Missing the required parameter `contract_address` when calling `coins_id_contract_contract_address_market_chart_range_get`"
            )  # noqa: E501
        # verify the required parameter 'vs_currency' is set
        if "vs_currency" not in params or params["vs_currency"] is None:
            raise ValueError(
                "Missing the required parameter `vs_currency` when calling `coins_id_contract_contract_address_market_chart_range_get`"
            )  # noqa: E501
        # verify the required parameter '_from' is set
        if "_from" not in params or params["_from"] is None:
            raise ValueError(
                "Missing the required parameter `_from` when calling `coins_id_contract_contract_address_market_chart_range_get`"
            )  # noqa: E501
        # verify the required parameter 'to' is set
        if "to" not in params or params["to"] is None:
            raise ValueError(
                "Missing the required parameter `to` when calling `coins_id_contract_contract_address_market_chart_range_get`"
            )  # noqa: E501

        collection_formats = {}

        path_params = {}
        if "id" in params:
            path_params["id"] = params["id"]  # noqa: E501
        if "contract_address" in params:
            path_params["contract_address"] = params["contract_address"]  # noqa: E501

        query_params = []
        if "vs_currency" in params:
            query_params.append(("vs_currency", params["vs_currency"]))  # noqa: E501
        if "_from" in params:
            query_params.append(("from", params["_from"]))  # noqa: E501
        if "to" in params:
            query_params.append(("to", params["to"]))  # noqa: E501

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # Authentication setting
        auth_settings = []  # noqa: E501

        return self.api_client.call_api(
            "/coins/{id}/contract/{contract_address}/market_chart/range",
            "GET",
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type=None,  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get("async_req"),
            _return_http_data_only=params.get("_return_http_data_only"),
            _preload_content=params.get("_preload_content", True),
            _request_timeout=params.get("_request_timeout"),
            collection_formats=collection_formats,
        )

    def coins_id_get(self, id, **kwargs):  # noqa: E501
        """Get current data (name, price, market, ... including exchange tickers) for a coin  # noqa: E501

        Get current data (name, price, market, ... including exchange tickers) for a coin.<br><br> **IMPORTANT**:  Ticker object is limited to 100 items, to get more tickers, use `/coins/{id}/tickers`  Ticker `is_stale` is true when ticker that has not been updated/unchanged from the exchange for a while.  Ticker `is_anomaly` is true if ticker's price is outliered by our system.  You are responsible for managing how you want to display these information (e.g. footnote, different background, change opacity, hide)   # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.coins_id_get(id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str id: pass the coin id (can be obtained from /coins) eg. bitcoin (required)
        :param str localization: Include all localized languages in response (true/false) <b>[default: true]</b>
        :param bool tickers: Include tickers data (true/false) <b>[default: true]</b>
        :param bool market_data: Include market_data (true/false) <b>[default: true]</b>
        :param bool community_data: Include community_data data (true/false) <b>[default: true]</b>
        :param bool developer_data: Include developer_data data (true/false) <b>[default: true]</b>
        :param bool sparkline: Include sparkline 7 days data (eg. true, false) <b>[default: false]</b>
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs["_return_http_data_only"] = True
        if kwargs.get("async_req"):
            return self.coins_id_get_with_http_info(id, **kwargs)  # noqa: E501
        else:
            (data) = self.coins_id_get_with_http_info(id, **kwargs)  # noqa: E501
            return data

    def coins_id_get_with_http_info(self, id, **kwargs):  # noqa: E501
        """Get current data (name, price, market, ... including exchange tickers) for a coin  # noqa: E501

        Get current data (name, price, market, ... including exchange tickers) for a coin.<br><br> **IMPORTANT**:  Ticker object is limited to 100 items, to get more tickers, use `/coins/{id}/tickers`  Ticker `is_stale` is true when ticker that has not been updated/unchanged from the exchange for a while.  Ticker `is_anomaly` is true if ticker's price is outliered by our system.  You are responsible for managing how you want to display these information (e.g. footnote, different background, change opacity, hide)   # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.coins_id_get_with_http_info(id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str id: pass the coin id (can be obtained from /coins) eg. bitcoin (required)
        :param str localization: Include all localized languages in response (true/false) <b>[default: true]</b>
        :param bool tickers: Include tickers data (true/false) <b>[default: true]</b>
        :param bool market_data: Include market_data (true/false) <b>[default: true]</b>
        :param bool community_data: Include community_data data (true/false) <b>[default: true]</b>
        :param bool developer_data: Include developer_data data (true/false) <b>[default: true]</b>
        :param bool sparkline: Include sparkline 7 days data (eg. true, false) <b>[default: false]</b>
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = [
            "id",
            "localization",
            "tickers",
            "market_data",
            "community_data",
            "developer_data",
            "sparkline",
        ]  # noqa: E501
        all_params.append("async_req")
        all_params.append("_return_http_data_only")
        all_params.append("_preload_content")
        all_params.append("_request_timeout")

        params = locals()
        for key, val in six.iteritems(params["kwargs"]):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method coins_id_get" % key
                )
            params[key] = val
        del params["kwargs"]
        # verify the required parameter 'id' is set
        if "id" not in params or params["id"] is None:
            raise ValueError(
                "Missing the required parameter `id` when calling `coins_id_get`"
            )  # noqa: E501

        collection_formats = {}

        path_params = {}
        if "id" in params:
            path_params["id"] = params["id"]  # noqa: E501

        query_params = []
        if "localization" in params:
            query_params.append(("localization", params["localization"]))  # noqa: E501
        if "tickers" in params:
            query_params.append(("tickers", params["tickers"]))  # noqa: E501
        if "market_data" in params:
            query_params.append(("market_data", params["market_data"]))  # noqa: E501
        if "community_data" in params:
            query_params.append(
                ("community_data", params["community_data"])
            )  # noqa: E501
        if "developer_data" in params:
            query_params.append(
                ("developer_data", params["developer_data"])
            )  # noqa: E501
        if "sparkline" in params:
            query_params.append(("sparkline", params["sparkline"]))  # noqa: E501

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # Authentication setting
        auth_settings = []  # noqa: E501

        return self.api_client.call_api(
            "/coins/{id}",
            "GET",
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type=None,  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get("async_req"),
            _return_http_data_only=params.get("_return_http_data_only"),
            _preload_content=params.get("_preload_content", True),
            _request_timeout=params.get("_request_timeout"),
            collection_formats=collection_formats,
        )

    def coins_id_history_get(self, id, _date, **kwargs):  # noqa: E501
        """Get historical data (name, price, market, stats) at a given date for a coin  # noqa: E501

        Get historical data (name, price, market, stats) at a given date for a coin   # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.coins_id_history_get(id, _date, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str id: pass the coin id (can be obtained from /coins) eg. bitcoin (required)
        :param str _date: The date of data snapshot in dd-mm-yyyy eg. 30-12-2017 (required)
        :param str localization: Set to false to exclude localized languages in response
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs["_return_http_data_only"] = True
        if kwargs.get("async_req"):
            return self.coins_id_history_get_with_http_info(
                id, _date, **kwargs
            )  # noqa: E501
        else:
            (data) = self.coins_id_history_get_with_http_info(
                id, _date, **kwargs
            )  # noqa: E501
            return data

    def coins_id_history_get_with_http_info(self, id, _date, **kwargs):  # noqa: E501
        """Get historical data (name, price, market, stats) at a given date for a coin  # noqa: E501

        Get historical data (name, price, market, stats) at a given date for a coin   # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.coins_id_history_get_with_http_info(id, _date, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str id: pass the coin id (can be obtained from /coins) eg. bitcoin (required)
        :param str _date: The date of data snapshot in dd-mm-yyyy eg. 30-12-2017 (required)
        :param str localization: Set to false to exclude localized languages in response
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ["id", "_date", "localization"]  # noqa: E501
        all_params.append("async_req")
        all_params.append("_return_http_data_only")
        all_params.append("_preload_content")
        all_params.append("_request_timeout")

        params = locals()
        for key, val in six.iteritems(params["kwargs"]):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method coins_id_history_get" % key
                )
            params[key] = val
        del params["kwargs"]
        # verify the required parameter 'id' is set
        if "id" not in params or params["id"] is None:
            raise ValueError(
                "Missing the required parameter `id` when calling `coins_id_history_get`"
            )  # noqa: E501
        # verify the required parameter '_date' is set
        if "_date" not in params or params["_date"] is None:
            raise ValueError(
                "Missing the required parameter `_date` when calling `coins_id_history_get`"
            )  # noqa: E501

        collection_formats = {}

        path_params = {}
        if "id" in params:
            path_params["id"] = params["id"]  # noqa: E501

        query_params = []
        if "_date" in params:
            query_params.append(("date", params["_date"]))  # noqa: E501
        if "localization" in params:
            query_params.append(("localization", params["localization"]))  # noqa: E501

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # Authentication setting
        auth_settings = []  # noqa: E501

        return self.api_client.call_api(
            "/coins/{id}/history",
            "GET",
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type=None,  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get("async_req"),
            _return_http_data_only=params.get("_return_http_data_only"),
            _preload_content=params.get("_preload_content", True),
            _request_timeout=params.get("_request_timeout"),
            collection_formats=collection_formats,
        )

    def coins_id_market_chart_get(self, id, vs_currency, days, **kwargs):  # noqa: E501
        """Get historical market data include price, market cap, and 24h volume (granularity auto)  # noqa: E501

        Get historical market data include price, market cap, and 24h volume (granularity auto)  <b>Minutely data will be used for duration within 1 day, Hourly data will be used for duration between 1 day and 90 days, Daily data will be used for duration above 90 days.</b>  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.coins_id_market_chart_get(id, vs_currency, days, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str id: pass the coin id (can be obtained from /coins) eg. bitcoin (required)
        :param str vs_currency: The target currency of market data (usd, eur, jpy, etc.) (required)
        :param str days: Data up to number of days ago (eg. 1,14,30,max) (required)
        :param str interval: Data interval. Possible value: daily
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs["_return_http_data_only"] = True
        if kwargs.get("async_req"):
            return self.coins_id_market_chart_get_with_http_info(
                id, vs_currency, days, **kwargs
            )  # noqa: E501
        else:
            (data) = self.coins_id_market_chart_get_with_http_info(
                id, vs_currency, days, **kwargs
            )  # noqa: E501
            return data

    def coins_id_market_chart_get_with_http_info(
        self, id, vs_currency, days, **kwargs
    ):  # noqa: E501
        """Get historical market data include price, market cap, and 24h volume (granularity auto)  # noqa: E501

        Get historical market data include price, market cap, and 24h volume (granularity auto)  <b>Minutely data will be used for duration within 1 day, Hourly data will be used for duration between 1 day and 90 days, Daily data will be used for duration above 90 days.</b>  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.coins_id_market_chart_get_with_http_info(id, vs_currency, days, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str id: pass the coin id (can be obtained from /coins) eg. bitcoin (required)
        :param str vs_currency: The target currency of market data (usd, eur, jpy, etc.) (required)
        :param str days: Data up to number of days ago (eg. 1,14,30,max) (required)
        :param str interval: Data interval. Possible value: daily
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ["id", "vs_currency", "days", "interval"]  # noqa: E501
        all_params.append("async_req")
        all_params.append("_return_http_data_only")
        all_params.append("_preload_content")
        all_params.append("_request_timeout")

        params = locals()
        for key, val in six.iteritems(params["kwargs"]):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method coins_id_market_chart_get" % key
                )
            params[key] = val
        del params["kwargs"]
        # verify the required parameter 'id' is set
        if "id" not in params or params["id"] is None:
            raise ValueError(
                "Missing the required parameter `id` when calling `coins_id_market_chart_get`"
            )  # noqa: E501
        # verify the required parameter 'vs_currency' is set
        if "vs_currency" not in params or params["vs_currency"] is None:
            raise ValueError(
                "Missing the required parameter `vs_currency` when calling `coins_id_market_chart_get`"
            )  # noqa: E501
        # verify the required parameter 'days' is set
        if "days" not in params or params["days"] is None:
            raise ValueError(
                "Missing the required parameter `days` when calling `coins_id_market_chart_get`"
            )  # noqa: E501

        collection_formats = {}

        path_params = {}
        if "id" in params:
            path_params["id"] = params["id"]  # noqa: E501

        query_params = []
        if "vs_currency" in params:
            query_params.append(("vs_currency", params["vs_currency"]))  # noqa: E501
        if "days" in params:
            query_params.append(("days", params["days"]))  # noqa: E501
        if "interval" in params:
            query_params.append(("interval", params["interval"]))  # noqa: E501

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # Authentication setting
        auth_settings = []  # noqa: E501

        return self.api_client.call_api(
            "/coins/{id}/market_chart",
            "GET",
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type=None,  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get("async_req"),
            _return_http_data_only=params.get("_return_http_data_only"),
            _preload_content=params.get("_preload_content", True),
            _request_timeout=params.get("_request_timeout"),
            collection_formats=collection_formats,
        )

    def coins_id_market_chart_range_get(
        self, id, vs_currency, _from, to, **kwargs
    ):  # noqa: E501
        """Get historical market data include price, market cap, and 24h volume within a range of timestamp (granularity auto)  # noqa: E501

        Get historical market data include price, market cap, and 24h volume within a range of timestamp (granularity auto)  <b><ul><li>Data granularity is automatic (cannot be adjusted)</li><li>1 day from query time = 5 minute interval data</li><li>1 - 90 days from query time = hourly data</li><li>above 90 days from query time = daily data (00:00 UTC)</li></ul> </b>  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.coins_id_market_chart_range_get(id, vs_currency, _from, to, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str id: pass the coin id (can be obtained from /coins) eg. bitcoin (required)
        :param str vs_currency: The target currency of market data (usd, eur, jpy, etc.) (required)
        :param str _from: From date in UNIX Timestamp (eg. 1392577232) (required)
        :param str to: To date in UNIX Timestamp (eg. 1422577232) (required)
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs["_return_http_data_only"] = True
        if kwargs.get("async_req"):
            return self.coins_id_market_chart_range_get_with_http_info(
                id, vs_currency, _from, to, **kwargs
            )  # noqa: E501
        else:
            (data) = self.coins_id_market_chart_range_get_with_http_info(
                id, vs_currency, _from, to, **kwargs
            )  # noqa: E501
            return data

    def coins_id_market_chart_range_get_with_http_info(
        self, id, vs_currency, _from, to, **kwargs
    ):  # noqa: E501
        """Get historical market data include price, market cap, and 24h volume within a range of timestamp (granularity auto)  # noqa: E501

        Get historical market data include price, market cap, and 24h volume within a range of timestamp (granularity auto)  <b><ul><li>Data granularity is automatic (cannot be adjusted)</li><li>1 day from query time = 5 minute interval data</li><li>1 - 90 days from query time = hourly data</li><li>above 90 days from query time = daily data (00:00 UTC)</li></ul> </b>  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.coins_id_market_chart_range_get_with_http_info(id, vs_currency, _from, to, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str id: pass the coin id (can be obtained from /coins) eg. bitcoin (required)
        :param str vs_currency: The target currency of market data (usd, eur, jpy, etc.) (required)
        :param str _from: From date in UNIX Timestamp (eg. 1392577232) (required)
        :param str to: To date in UNIX Timestamp (eg. 1422577232) (required)
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ["id", "vs_currency", "_from", "to"]  # noqa: E501
        all_params.append("async_req")
        all_params.append("_return_http_data_only")
        all_params.append("_preload_content")
        all_params.append("_request_timeout")

        params = locals()
        for key, val in six.iteritems(params["kwargs"]):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method coins_id_market_chart_range_get" % key
                )
            params[key] = val
        del params["kwargs"]
        # verify the required parameter 'id' is set
        if "id" not in params or params["id"] is None:
            raise ValueError(
                "Missing the required parameter `id` when calling `coins_id_market_chart_range_get`"
            )  # noqa: E501
        # verify the required parameter 'vs_currency' is set
        if "vs_currency" not in params or params["vs_currency"] is None:
            raise ValueError(
                "Missing the required parameter `vs_currency` when calling `coins_id_market_chart_range_get`"
            )  # noqa: E501
        # verify the required parameter '_from' is set
        if "_from" not in params or params["_from"] is None:
            raise ValueError(
                "Missing the required parameter `_from` when calling `coins_id_market_chart_range_get`"
            )  # noqa: E501
        # verify the required parameter 'to' is set
        if "to" not in params or params["to"] is None:
            raise ValueError(
                "Missing the required parameter `to` when calling `coins_id_market_chart_range_get`"
            )  # noqa: E501

        collection_formats = {}

        path_params = {}
        if "id" in params:
            path_params["id"] = params["id"]  # noqa: E501

        query_params = []
        if "vs_currency" in params:
            query_params.append(("vs_currency", params["vs_currency"]))  # noqa: E501
        if "_from" in params:
            query_params.append(("from", params["_from"]))  # noqa: E501
        if "to" in params:
            query_params.append(("to", params["to"]))  # noqa: E501

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # Authentication setting
        auth_settings = []  # noqa: E501

        return self.api_client.call_api(
            "/coins/{id}/market_chart/range",
            "GET",
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type=None,  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get("async_req"),
            _return_http_data_only=params.get("_return_http_data_only"),
            _preload_content=params.get("_preload_content", True),
            _request_timeout=params.get("_request_timeout"),
            collection_formats=collection_formats,
        )

    def coins_id_ohlc_get(self, id, vs_currency, days, **kwargs):  # noqa: E501
        """Get coin's OHLC  # noqa: E501

        Candle's body:  1 - 2 days: 30 minutes 3 - 30 days: 4 hours 31 and before: 4 days  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.coins_id_ohlc_get(id, vs_currency, days, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str id: pass the coin id (can be obtained from /coins/list) eg. bitcoin (required)
        :param str vs_currency: The target currency of market data (usd, eur, jpy, etc.) (required)
        :param int days:  Data up to number of days ago (1/7/14/30/90/180/365/max) (required)
        :return: list[float]
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs["_return_http_data_only"] = True
        if kwargs.get("async_req"):
            return self.coins_id_ohlc_get_with_http_info(
                id, vs_currency, days, **kwargs
            )  # noqa: E501
        else:
            (data) = self.coins_id_ohlc_get_with_http_info(
                id, vs_currency, days, **kwargs
            )  # noqa: E501
            return data

    def coins_id_ohlc_get_with_http_info(
        self, id, vs_currency, days, **kwargs
    ):  # noqa: E501
        """Get coin's OHLC  # noqa: E501

        Candle's body:  1 - 2 days: 30 minutes 3 - 30 days: 4 hours 31 and before: 4 days  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.coins_id_ohlc_get_with_http_info(id, vs_currency, days, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str id: pass the coin id (can be obtained from /coins/list) eg. bitcoin (required)
        :param str vs_currency: The target currency of market data (usd, eur, jpy, etc.) (required)
        :param int days:  Data up to number of days ago (1/7/14/30/90/180/365/max) (required)
        :return: list[float]
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ["id", "vs_currency", "days"]  # noqa: E501
        all_params.append("async_req")
        all_params.append("_return_http_data_only")
        all_params.append("_preload_content")
        all_params.append("_request_timeout")

        params = locals()
        for key, val in six.iteritems(params["kwargs"]):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method coins_id_ohlc_get" % key
                )
            params[key] = val
        del params["kwargs"]
        # verify the required parameter 'id' is set
        if "id" not in params or params["id"] is None:
            raise ValueError(
                "Missing the required parameter `id` when calling `coins_id_ohlc_get`"
            )  # noqa: E501
        # verify the required parameter 'vs_currency' is set
        if "vs_currency" not in params or params["vs_currency"] is None:
            raise ValueError(
                "Missing the required parameter `vs_currency` when calling `coins_id_ohlc_get`"
            )  # noqa: E501
        # verify the required parameter 'days' is set
        if "days" not in params or params["days"] is None:
            raise ValueError(
                "Missing the required parameter `days` when calling `coins_id_ohlc_get`"
            )  # noqa: E501

        collection_formats = {}

        path_params = {}
        if "id" in params:
            path_params["id"] = params["id"]  # noqa: E501

        query_params = []
        if "vs_currency" in params:
            query_params.append(("vs_currency", params["vs_currency"]))  # noqa: E501
        if "days" in params:
            query_params.append(("days", params["days"]))  # noqa: E501

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params["Accept"] = self.api_client.select_header_accept(
            ["application/json"]
        )  # noqa: E501

        # Authentication setting
        auth_settings = []  # noqa: E501

        return self.api_client.call_api(
            "/coins/{id}/ohlc",
            "GET",
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type="list[float]",  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get("async_req"),
            _return_http_data_only=params.get("_return_http_data_only"),
            _preload_content=params.get("_preload_content", True),
            _request_timeout=params.get("_request_timeout"),
            collection_formats=collection_formats,
        )

    def coins_id_status_updates_get(self, id, **kwargs):  # noqa: E501
        """Get status updates for a given coin  # noqa: E501

        Get status updates for a given coin  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.coins_id_status_updates_get(id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str id: pass the coin id (can be obtained from /coins) eg. bitcoin (required)
        :param int per_page: Total results per page
        :param int page: Page through results
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs["_return_http_data_only"] = True
        if kwargs.get("async_req"):
            return self.coins_id_status_updates_get_with_http_info(
                id, **kwargs
            )  # noqa: E501
        else:
            (data) = self.coins_id_status_updates_get_with_http_info(
                id, **kwargs
            )  # noqa: E501
            return data

    def coins_id_status_updates_get_with_http_info(self, id, **kwargs):  # noqa: E501
        """Get status updates for a given coin  # noqa: E501

        Get status updates for a given coin  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.coins_id_status_updates_get_with_http_info(id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str id: pass the coin id (can be obtained from /coins) eg. bitcoin (required)
        :param int per_page: Total results per page
        :param int page: Page through results
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ["id", "per_page", "page"]  # noqa: E501
        all_params.append("async_req")
        all_params.append("_return_http_data_only")
        all_params.append("_preload_content")
        all_params.append("_request_timeout")

        params = locals()
        for key, val in six.iteritems(params["kwargs"]):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method coins_id_status_updates_get" % key
                )
            params[key] = val
        del params["kwargs"]
        # verify the required parameter 'id' is set
        if "id" not in params or params["id"] is None:
            raise ValueError(
                "Missing the required parameter `id` when calling `coins_id_status_updates_get`"
            )  # noqa: E501

        collection_formats = {}

        path_params = {}
        if "id" in params:
            path_params["id"] = params["id"]  # noqa: E501

        query_params = []
        if "per_page" in params:
            query_params.append(("per_page", params["per_page"]))  # noqa: E501
        if "page" in params:
            query_params.append(("page", params["page"]))  # noqa: E501

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # Authentication setting
        auth_settings = []  # noqa: E501

        return self.api_client.call_api(
            "/coins/{id}/status_updates",
            "GET",
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type=None,  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get("async_req"),
            _return_http_data_only=params.get("_return_http_data_only"),
            _preload_content=params.get("_preload_content", True),
            _request_timeout=params.get("_request_timeout"),
            collection_formats=collection_formats,
        )

    def coins_id_tickers_get(self, id, **kwargs):  # noqa: E501
        """Get coin tickers (paginated to 100 items)  # noqa: E501

        Get coin tickers (paginated to 100 items)<br><br> **IMPORTANT**:  Ticker `is_stale` is true when ticker that has not been updated/unchanged from the exchange for a while.  Ticker `is_anomaly` is true if ticker's price is outliered by our system.  You are responsible for managing how you want to display these information (e.g. footnote, different background, change opacity, hide)   # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.coins_id_tickers_get(id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str id: pass the coin id (can be obtained from /coins/list) eg. bitcoin (required)
        :param str exchange_ids: filter results by exchange_ids (ref: v3/exchanges/list)
        :param str include_exchange_logo: flag to show exchange_logo
        :param int page: Page through results
        :param str order: valid values: <b>trust_score_desc (default), trust_score_asc and volume_desc</b>
        :param str depth: flag to show 2% orderbook depth. valid values: true, false
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs["_return_http_data_only"] = True
        if kwargs.get("async_req"):
            return self.coins_id_tickers_get_with_http_info(id, **kwargs)  # noqa: E501
        else:
            (data) = self.coins_id_tickers_get_with_http_info(
                id, **kwargs
            )  # noqa: E501
            return data

    def coins_id_tickers_get_with_http_info(self, id, **kwargs):  # noqa: E501
        """Get coin tickers (paginated to 100 items)  # noqa: E501

        Get coin tickers (paginated to 100 items)<br><br> **IMPORTANT**:  Ticker `is_stale` is true when ticker that has not been updated/unchanged from the exchange for a while.  Ticker `is_anomaly` is true if ticker's price is outliered by our system.  You are responsible for managing how you want to display these information (e.g. footnote, different background, change opacity, hide)   # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.coins_id_tickers_get_with_http_info(id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str id: pass the coin id (can be obtained from /coins/list) eg. bitcoin (required)
        :param str exchange_ids: filter results by exchange_ids (ref: v3/exchanges/list)
        :param str include_exchange_logo: flag to show exchange_logo
        :param int page: Page through results
        :param str order: valid values: <b>trust_score_desc (default), trust_score_asc and volume_desc</b>
        :param str depth: flag to show 2% orderbook depth. valid values: true, false
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = [
            "id",
            "exchange_ids",
            "include_exchange_logo",
            "page",
            "order",
            "depth",
        ]  # noqa: E501
        all_params.append("async_req")
        all_params.append("_return_http_data_only")
        all_params.append("_preload_content")
        all_params.append("_request_timeout")

        params = locals()
        for key, val in six.iteritems(params["kwargs"]):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method coins_id_tickers_get" % key
                )
            params[key] = val
        del params["kwargs"]
        # verify the required parameter 'id' is set
        if "id" not in params or params["id"] is None:
            raise ValueError(
                "Missing the required parameter `id` when calling `coins_id_tickers_get`"
            )  # noqa: E501

        collection_formats = {}

        path_params = {}
        if "id" in params:
            path_params["id"] = params["id"]  # noqa: E501

        query_params = []
        if "exchange_ids" in params:
            query_params.append(("exchange_ids", params["exchange_ids"]))  # noqa: E501
        if "include_exchange_logo" in params:
            query_params.append(
                ("include_exchange_logo", params["include_exchange_logo"])
            )  # noqa: E501
        if "page" in params:
            query_params.append(("page", params["page"]))  # noqa: E501
        if "order" in params:
            query_params.append(("order", params["order"]))  # noqa: E501
        if "depth" in params:
            query_params.append(("depth", params["depth"]))  # noqa: E501

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # Authentication setting
        auth_settings = []  # noqa: E501

        return self.api_client.call_api(
            "/coins/{id}/tickers",
            "GET",
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type=None,  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get("async_req"),
            _return_http_data_only=params.get("_return_http_data_only"),
            _preload_content=params.get("_preload_content", True),
            _request_timeout=params.get("_request_timeout"),
            collection_formats=collection_formats,
        )

    def coins_list_get(self, **kwargs):  # noqa: E501
        """List all supported coins id, name and symbol (no pagination required)  # noqa: E501

        Use this to obtain all the coins' id in order to make API calls  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.coins_list_get(async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param bool include_platform: flag to include platform contract addresses (eg. 0x.... for Ethereum based tokens).   valid values: true, false
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs["_return_http_data_only"] = True
        if kwargs.get("async_req"):
            return self.coins_list_get_with_http_info(**kwargs)  # noqa: E501
        else:
            (data) = self.coins_list_get_with_http_info(**kwargs)  # noqa: E501
            return data

    def coins_list_get_with_http_info(self, **kwargs):  # noqa: E501
        """List all supported coins id, name and symbol (no pagination required)  # noqa: E501

        Use this to obtain all the coins' id in order to make API calls  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.coins_list_get_with_http_info(async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param bool include_platform: flag to include platform contract addresses (eg. 0x.... for Ethereum based tokens).   valid values: true, false
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ["include_platform"]  # noqa: E501
        all_params.append("async_req")
        all_params.append("_return_http_data_only")
        all_params.append("_preload_content")
        all_params.append("_request_timeout")

        params = locals()
        for key, val in six.iteritems(params["kwargs"]):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method coins_list_get" % key
                )
            params[key] = val
        del params["kwargs"]

        collection_formats = {}

        path_params = {}

        query_params = []
        if "include_platform" in params:
            query_params.append(
                ("include_platform", params["include_platform"])
            )  # noqa: E501

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # Authentication setting
        auth_settings = []  # noqa: E501

        return self.api_client.call_api(
            "/coins/list",
            "GET",
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type=None,  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get("async_req"),
            _return_http_data_only=params.get("_return_http_data_only"),
            _preload_content=params.get("_preload_content", True),
            _request_timeout=params.get("_request_timeout"),
            collection_formats=collection_formats,
        )

    def coins_markets_get(self, vs_currency, **kwargs):  # noqa: E501
        """List all supported coins price, market cap, volume, and market related data  # noqa: E501

        Use this to obtain all the coins market data (price, market cap, volume)  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.coins_markets_get(vs_currency, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str vs_currency: The target currency of market data (usd, eur, jpy, etc.) (required)
        :param str ids: The ids of the coin, comma separated crytocurrency symbols (base). refers to `/coins/list`. <b>When left empty, returns numbers the coins observing the params `limit` and `start`</b>
        :param str category: filter by coin category. Refer to /coin/categories/list
        :param str order: valid values: <b>market_cap_desc, gecko_desc, gecko_asc, market_cap_asc, market_cap_desc, volume_asc, volume_desc, id_asc, id_desc</b> sort results by field.
        :param int per_page: valid values: 1..250  Total results per page
        :param int page: Page through results
        :param bool sparkline: Include sparkline 7 days data (eg. true, false)
        :param str price_change_percentage: Include price change percentage in <b>1h, 24h, 7d, 14d, 30d, 200d, 1y</b> (eg. '`1h,24h,7d`' comma-separated, invalid values will be discarded)
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs["_return_http_data_only"] = True
        if kwargs.get("async_req"):
            return self.coins_markets_get_with_http_info(
                vs_currency, **kwargs
            )  # noqa: E501
        else:
            (data) = self.coins_markets_get_with_http_info(
                vs_currency, **kwargs
            )  # noqa: E501
            return data

    def coins_markets_get_with_http_info(self, vs_currency, **kwargs):  # noqa: E501
        """List all supported coins price, market cap, volume, and market related data  # noqa: E501

        Use this to obtain all the coins market data (price, market cap, volume)  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.coins_markets_get_with_http_info(vs_currency, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str vs_currency: The target currency of market data (usd, eur, jpy, etc.) (required)
        :param str ids: The ids of the coin, comma separated crytocurrency symbols (base). refers to `/coins/list`. <b>When left empty, returns numbers the coins observing the params `limit` and `start`</b>
        :param str category: filter by coin category. Refer to /coin/categories/list
        :param str order: valid values: <b>market_cap_desc, gecko_desc, gecko_asc, market_cap_asc, market_cap_desc, volume_asc, volume_desc, id_asc, id_desc</b> sort results by field.
        :param int per_page: valid values: 1..250  Total results per page
        :param int page: Page through results
        :param bool sparkline: Include sparkline 7 days data (eg. true, false)
        :param str price_change_percentage: Include price change percentage in <b>1h, 24h, 7d, 14d, 30d, 200d, 1y</b> (eg. '`1h,24h,7d`' comma-separated, invalid values will be discarded)
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = [
            "vs_currency",
            "ids",
            "category",
            "order",
            "per_page",
            "page",
            "sparkline",
            "price_change_percentage",
        ]  # noqa: E501
        all_params.append("async_req")
        all_params.append("_return_http_data_only")
        all_params.append("_preload_content")
        all_params.append("_request_timeout")

        params = locals()
        for key, val in six.iteritems(params["kwargs"]):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method coins_markets_get" % key
                )
            params[key] = val
        del params["kwargs"]
        # verify the required parameter 'vs_currency' is set
        if "vs_currency" not in params or params["vs_currency"] is None:
            raise ValueError(
                "Missing the required parameter `vs_currency` when calling `coins_markets_get`"
            )  # noqa: E501

        collection_formats = {}

        path_params = {}

        query_params = []
        if "vs_currency" in params:
            query_params.append(("vs_currency", params["vs_currency"]))  # noqa: E501
        if "ids" in params:
            query_params.append(("ids", params["ids"]))  # noqa: E501
        if "category" in params:
            query_params.append(("category", params["category"]))  # noqa: E501
        if "order" in params:
            query_params.append(("order", params["order"]))  # noqa: E501
        if "per_page" in params:
            query_params.append(("per_page", params["per_page"]))  # noqa: E501
        if "page" in params:
            query_params.append(("page", params["page"]))  # noqa: E501
        if "sparkline" in params:
            query_params.append(("sparkline", params["sparkline"]))  # noqa: E501
        if "price_change_percentage" in params:
            query_params.append(
                ("price_change_percentage", params["price_change_percentage"])
            )  # noqa: E501

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # Authentication setting
        auth_settings = []  # noqa: E501

        return self.api_client.call_api(
            "/coins/markets",
            "GET",
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type=None,  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get("async_req"),
            _return_http_data_only=params.get("_return_http_data_only"),
            _preload_content=params.get("_preload_content", True),
            _request_timeout=params.get("_request_timeout"),
            collection_formats=collection_formats,
        )

    def companies_public_treasury_coin_id_get(self, coin_id, **kwargs):  # noqa: E501
        """Get public companies data  # noqa: E501

        Get public companies bitcoin or ethereum holdings (Ordered by total holdings descending)  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.companies_public_treasury_coin_id_get(coin_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str coin_id: bitcoin or ethereum (required)
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs["_return_http_data_only"] = True
        if kwargs.get("async_req"):
            return self.companies_public_treasury_coin_id_get_with_http_info(
                coin_id, **kwargs
            )  # noqa: E501
        else:
            (data) = self.companies_public_treasury_coin_id_get_with_http_info(
                coin_id, **kwargs
            )  # noqa: E501
            return data

    def companies_public_treasury_coin_id_get_with_http_info(
        self, coin_id, **kwargs
    ):  # noqa: E501
        """Get public companies data  # noqa: E501

        Get public companies bitcoin or ethereum holdings (Ordered by total holdings descending)  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.companies_public_treasury_coin_id_get_with_http_info(coin_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str coin_id: bitcoin or ethereum (required)
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ["coin_id"]  # noqa: E501
        all_params.append("async_req")
        all_params.append("_return_http_data_only")
        all_params.append("_preload_content")
        all_params.append("_request_timeout")

        params = locals()
        for key, val in six.iteritems(params["kwargs"]):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method companies_public_treasury_coin_id_get" % key
                )
            params[key] = val
        del params["kwargs"]
        # verify the required parameter 'coin_id' is set
        if "coin_id" not in params or params["coin_id"] is None:
            raise ValueError(
                "Missing the required parameter `coin_id` when calling `companies_public_treasury_coin_id_get`"
            )  # noqa: E501

        collection_formats = {}

        path_params = {}
        if "coin_id" in params:
            path_params["coin_id"] = params["coin_id"]  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # Authentication setting
        auth_settings = []  # noqa: E501

        return self.api_client.call_api(
            "/companies/public_treasury/{coin_id}",
            "GET",
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type=None,  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get("async_req"),
            _return_http_data_only=params.get("_return_http_data_only"),
            _preload_content=params.get("_preload_content", True),
            _request_timeout=params.get("_request_timeout"),
            collection_formats=collection_formats,
        )

    def derivatives_exchanges_get(self, **kwargs):  # noqa: E501
        """List all derivative exchanges  # noqa: E501

        List all derivative exchanges  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.derivatives_exchanges_get(async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str order: order results using following params name_asc，name_desc，open_interest_btc_asc，open_interest_btc_desc，trade_volume_24h_btc_asc，trade_volume_24h_btc_desc
        :param int per_page: Total results per page
        :param int page: Page through results
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs["_return_http_data_only"] = True
        if kwargs.get("async_req"):
            return self.derivatives_exchanges_get_with_http_info(**kwargs)  # noqa: E501
        else:
            (data) = self.derivatives_exchanges_get_with_http_info(
                **kwargs
            )  # noqa: E501
            return data

    def derivatives_exchanges_get_with_http_info(self, **kwargs):  # noqa: E501
        """List all derivative exchanges  # noqa: E501

        List all derivative exchanges  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.derivatives_exchanges_get_with_http_info(async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str order: order results using following params name_asc，name_desc，open_interest_btc_asc，open_interest_btc_desc，trade_volume_24h_btc_asc，trade_volume_24h_btc_desc
        :param int per_page: Total results per page
        :param int page: Page through results
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ["order", "per_page", "page"]  # noqa: E501
        all_params.append("async_req")
        all_params.append("_return_http_data_only")
        all_params.append("_preload_content")
        all_params.append("_request_timeout")

        params = locals()
        for key, val in six.iteritems(params["kwargs"]):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method derivatives_exchanges_get" % key
                )
            params[key] = val
        del params["kwargs"]

        collection_formats = {}

        path_params = {}

        query_params = []
        if "order" in params:
            query_params.append(("order", params["order"]))  # noqa: E501
        if "per_page" in params:
            query_params.append(("per_page", params["per_page"]))  # noqa: E501
        if "page" in params:
            query_params.append(("page", params["page"]))  # noqa: E501

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # Authentication setting
        auth_settings = []  # noqa: E501

        return self.api_client.call_api(
            "/derivatives/exchanges",
            "GET",
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type=None,  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get("async_req"),
            _return_http_data_only=params.get("_return_http_data_only"),
            _preload_content=params.get("_preload_content", True),
            _request_timeout=params.get("_request_timeout"),
            collection_formats=collection_formats,
        )

    def derivatives_exchanges_id_get(self, id, **kwargs):  # noqa: E501
        """show derivative exchange data  # noqa: E501

        show derivative exchange data  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.derivatives_exchanges_id_get(id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str id: pass the exchange id (can be obtained from derivatives/exchanges/list) eg. bitmex (required)
        :param str include_tickers: ['all', 'unexpired'] - expired to show unexpired tickers, all to list all tickers, leave blank to omit tickers data in response
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs["_return_http_data_only"] = True
        if kwargs.get("async_req"):
            return self.derivatives_exchanges_id_get_with_http_info(
                id, **kwargs
            )  # noqa: E501
        else:
            (data) = self.derivatives_exchanges_id_get_with_http_info(
                id, **kwargs
            )  # noqa: E501
            return data

    def derivatives_exchanges_id_get_with_http_info(self, id, **kwargs):  # noqa: E501
        """show derivative exchange data  # noqa: E501

        show derivative exchange data  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.derivatives_exchanges_id_get_with_http_info(id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str id: pass the exchange id (can be obtained from derivatives/exchanges/list) eg. bitmex (required)
        :param str include_tickers: ['all', 'unexpired'] - expired to show unexpired tickers, all to list all tickers, leave blank to omit tickers data in response
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ["id", "include_tickers"]  # noqa: E501
        all_params.append("async_req")
        all_params.append("_return_http_data_only")
        all_params.append("_preload_content")
        all_params.append("_request_timeout")

        params = locals()
        for key, val in six.iteritems(params["kwargs"]):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method derivatives_exchanges_id_get" % key
                )
            params[key] = val
        del params["kwargs"]
        # verify the required parameter 'id' is set
        if "id" not in params or params["id"] is None:
            raise ValueError(
                "Missing the required parameter `id` when calling `derivatives_exchanges_id_get`"
            )  # noqa: E501

        collection_formats = {}

        path_params = {}
        if "id" in params:
            path_params["id"] = params["id"]  # noqa: E501

        query_params = []
        if "include_tickers" in params:
            query_params.append(
                ("include_tickers", params["include_tickers"])
            )  # noqa: E501

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # Authentication setting
        auth_settings = []  # noqa: E501

        return self.api_client.call_api(
            "/derivatives/exchanges/{id}",
            "GET",
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type=None,  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get("async_req"),
            _return_http_data_only=params.get("_return_http_data_only"),
            _preload_content=params.get("_preload_content", True),
            _request_timeout=params.get("_request_timeout"),
            collection_formats=collection_formats,
        )

    def derivatives_exchanges_list_get(self, **kwargs):  # noqa: E501
        """List all derivative exchanges name and identifier  # noqa: E501

        List all derivative exchanges name and identifier  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.derivatives_exchanges_list_get(async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs["_return_http_data_only"] = True
        if kwargs.get("async_req"):
            return self.derivatives_exchanges_list_get_with_http_info(
                **kwargs
            )  # noqa: E501
        else:
            (data) = self.derivatives_exchanges_list_get_with_http_info(
                **kwargs
            )  # noqa: E501
            return data

    def derivatives_exchanges_list_get_with_http_info(self, **kwargs):  # noqa: E501
        """List all derivative exchanges name and identifier  # noqa: E501

        List all derivative exchanges name and identifier  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.derivatives_exchanges_list_get_with_http_info(async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = []  # noqa: E501
        all_params.append("async_req")
        all_params.append("_return_http_data_only")
        all_params.append("_preload_content")
        all_params.append("_request_timeout")

        params = locals()
        for key, val in six.iteritems(params["kwargs"]):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method derivatives_exchanges_list_get" % key
                )
            params[key] = val
        del params["kwargs"]

        collection_formats = {}

        path_params = {}

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # Authentication setting
        auth_settings = []  # noqa: E501

        return self.api_client.call_api(
            "/derivatives/exchanges/list",
            "GET",
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type=None,  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get("async_req"),
            _return_http_data_only=params.get("_return_http_data_only"),
            _preload_content=params.get("_preload_content", True),
            _request_timeout=params.get("_request_timeout"),
            collection_formats=collection_formats,
        )

    def derivatives_get(self, **kwargs):  # noqa: E501
        """List all derivative tickers  # noqa: E501

        List all derivative tickers  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.derivatives_get(async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str include_tickers: ['all', 'unexpired'] - expired to show unexpired tickers, all to list all tickers, defaults to unexpired
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs["_return_http_data_only"] = True
        if kwargs.get("async_req"):
            return self.derivatives_get_with_http_info(**kwargs)  # noqa: E501
        else:
            (data) = self.derivatives_get_with_http_info(**kwargs)  # noqa: E501
            return data

    def derivatives_get_with_http_info(self, **kwargs):  # noqa: E501
        """List all derivative tickers  # noqa: E501

        List all derivative tickers  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.derivatives_get_with_http_info(async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str include_tickers: ['all', 'unexpired'] - expired to show unexpired tickers, all to list all tickers, defaults to unexpired
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ["include_tickers"]  # noqa: E501
        all_params.append("async_req")
        all_params.append("_return_http_data_only")
        all_params.append("_preload_content")
        all_params.append("_request_timeout")

        params = locals()
        for key, val in six.iteritems(params["kwargs"]):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method derivatives_get" % key
                )
            params[key] = val
        del params["kwargs"]

        collection_formats = {}

        path_params = {}

        query_params = []
        if "include_tickers" in params:
            query_params.append(
                ("include_tickers", params["include_tickers"])
            )  # noqa: E501

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # Authentication setting
        auth_settings = []  # noqa: E501

        return self.api_client.call_api(
            "/derivatives",
            "GET",
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type=None,  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get("async_req"),
            _return_http_data_only=params.get("_return_http_data_only"),
            _preload_content=params.get("_preload_content", True),
            _request_timeout=params.get("_request_timeout"),
            collection_formats=collection_formats,
        )

    def exchange_rates_get(self, **kwargs):  # noqa: E501
        """Get BTC-to-Currency exchange rates  # noqa: E501

        Get BTC-to-Currency exchange rates   # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.exchange_rates_get(async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs["_return_http_data_only"] = True
        if kwargs.get("async_req"):
            return self.exchange_rates_get_with_http_info(**kwargs)  # noqa: E501
        else:
            (data) = self.exchange_rates_get_with_http_info(**kwargs)  # noqa: E501
            return data

    def exchange_rates_get_with_http_info(self, **kwargs):  # noqa: E501
        """Get BTC-to-Currency exchange rates  # noqa: E501

        Get BTC-to-Currency exchange rates   # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.exchange_rates_get_with_http_info(async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = []  # noqa: E501
        all_params.append("async_req")
        all_params.append("_return_http_data_only")
        all_params.append("_preload_content")
        all_params.append("_request_timeout")

        params = locals()
        for key, val in six.iteritems(params["kwargs"]):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method exchange_rates_get" % key
                )
            params[key] = val
        del params["kwargs"]

        collection_formats = {}

        path_params = {}

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # Authentication setting
        auth_settings = []  # noqa: E501

        return self.api_client.call_api(
            "/exchange_rates",
            "GET",
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type=None,  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get("async_req"),
            _return_http_data_only=params.get("_return_http_data_only"),
            _preload_content=params.get("_preload_content", True),
            _request_timeout=params.get("_request_timeout"),
            collection_formats=collection_formats,
        )

    def exchanges_get(self, **kwargs):  # noqa: E501
        """List all exchanges  # noqa: E501

        List all exchanges  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.exchanges_get(async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param int per_page: Valid values: 1...250 Total results per page Default value:: 100
        :param str page: page through results
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs["_return_http_data_only"] = True
        if kwargs.get("async_req"):
            return self.exchanges_get_with_http_info(**kwargs)  # noqa: E501
        else:
            (data) = self.exchanges_get_with_http_info(**kwargs)  # noqa: E501
            return data

    def exchanges_get_with_http_info(self, **kwargs):  # noqa: E501
        """List all exchanges  # noqa: E501

        List all exchanges  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.exchanges_get_with_http_info(async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param int per_page: Valid values: 1...250 Total results per page Default value:: 100
        :param str page: page through results
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ["per_page", "page"]  # noqa: E501
        all_params.append("async_req")
        all_params.append("_return_http_data_only")
        all_params.append("_preload_content")
        all_params.append("_request_timeout")

        params = locals()
        for key, val in six.iteritems(params["kwargs"]):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method exchanges_get" % key
                )
            params[key] = val
        del params["kwargs"]

        collection_formats = {}

        path_params = {}

        query_params = []
        if "per_page" in params:
            query_params.append(("per_page", params["per_page"]))  # noqa: E501
        if "page" in params:
            query_params.append(("page", params["page"]))  # noqa: E501

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # Authentication setting
        auth_settings = []  # noqa: E501

        return self.api_client.call_api(
            "/exchanges",
            "GET",
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type=None,  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get("async_req"),
            _return_http_data_only=params.get("_return_http_data_only"),
            _preload_content=params.get("_preload_content", True),
            _request_timeout=params.get("_request_timeout"),
            collection_formats=collection_formats,
        )

    def exchanges_id_get(self, id, **kwargs):  # noqa: E501
        """Get exchange volume in BTC and top 100 tickers only  # noqa: E501

        Get exchange volume in BTC and tickers<br><br> **IMPORTANT**:  Ticker object is limited to 100 items, to get more tickers, use `/exchanges/{id}/tickers`  Ticker `is_stale` is true when ticker that has not been updated/unchanged from the exchange for a while.  Ticker `is_anomaly` is true if ticker's price is outliered by our system.  You are responsible for managing how you want to display these information (e.g. footnote, different background, change opacity, hide)   # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.exchanges_id_get(id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str id: pass the exchange id (can be obtained from /exchanges/list) eg. binance (required)
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs["_return_http_data_only"] = True
        if kwargs.get("async_req"):
            return self.exchanges_id_get_with_http_info(id, **kwargs)  # noqa: E501
        else:
            (data) = self.exchanges_id_get_with_http_info(id, **kwargs)  # noqa: E501
            return data

    def exchanges_id_get_with_http_info(self, id, **kwargs):  # noqa: E501
        """Get exchange volume in BTC and top 100 tickers only  # noqa: E501

        Get exchange volume in BTC and tickers<br><br> **IMPORTANT**:  Ticker object is limited to 100 items, to get more tickers, use `/exchanges/{id}/tickers`  Ticker `is_stale` is true when ticker that has not been updated/unchanged from the exchange for a while.  Ticker `is_anomaly` is true if ticker's price is outliered by our system.  You are responsible for managing how you want to display these information (e.g. footnote, different background, change opacity, hide)   # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.exchanges_id_get_with_http_info(id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str id: pass the exchange id (can be obtained from /exchanges/list) eg. binance (required)
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ["id"]  # noqa: E501
        all_params.append("async_req")
        all_params.append("_return_http_data_only")
        all_params.append("_preload_content")
        all_params.append("_request_timeout")

        params = locals()
        for key, val in six.iteritems(params["kwargs"]):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method exchanges_id_get" % key
                )
            params[key] = val
        del params["kwargs"]
        # verify the required parameter 'id' is set
        if "id" not in params or params["id"] is None:
            raise ValueError(
                "Missing the required parameter `id` when calling `exchanges_id_get`"
            )  # noqa: E501

        collection_formats = {}

        path_params = {}
        if "id" in params:
            path_params["id"] = params["id"]  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # Authentication setting
        auth_settings = []  # noqa: E501

        return self.api_client.call_api(
            "/exchanges/{id}",
            "GET",
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type=None,  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get("async_req"),
            _return_http_data_only=params.get("_return_http_data_only"),
            _preload_content=params.get("_preload_content", True),
            _request_timeout=params.get("_request_timeout"),
            collection_formats=collection_formats,
        )

    def exchanges_id_status_updates_get(self, id, **kwargs):  # noqa: E501
        """Get status updates for a given exchange  # noqa: E501

        Get status updates for a given exchange  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.exchanges_id_status_updates_get(id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str id: pass the exchange id (can be obtained from /exchanges/list) eg. binance (required)
        :param int per_page: Total results per page
        :param int page: Page through results
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs["_return_http_data_only"] = True
        if kwargs.get("async_req"):
            return self.exchanges_id_status_updates_get_with_http_info(
                id, **kwargs
            )  # noqa: E501
        else:
            (data) = self.exchanges_id_status_updates_get_with_http_info(
                id, **kwargs
            )  # noqa: E501
            return data

    def exchanges_id_status_updates_get_with_http_info(
        self, id, **kwargs
    ):  # noqa: E501
        """Get status updates for a given exchange  # noqa: E501

        Get status updates for a given exchange  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.exchanges_id_status_updates_get_with_http_info(id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str id: pass the exchange id (can be obtained from /exchanges/list) eg. binance (required)
        :param int per_page: Total results per page
        :param int page: Page through results
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ["id", "per_page", "page"]  # noqa: E501
        all_params.append("async_req")
        all_params.append("_return_http_data_only")
        all_params.append("_preload_content")
        all_params.append("_request_timeout")

        params = locals()
        for key, val in six.iteritems(params["kwargs"]):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method exchanges_id_status_updates_get" % key
                )
            params[key] = val
        del params["kwargs"]
        # verify the required parameter 'id' is set
        if "id" not in params or params["id"] is None:
            raise ValueError(
                "Missing the required parameter `id` when calling `exchanges_id_status_updates_get`"
            )  # noqa: E501

        collection_formats = {}

        path_params = {}
        if "id" in params:
            path_params["id"] = params["id"]  # noqa: E501

        query_params = []
        if "per_page" in params:
            query_params.append(("per_page", params["per_page"]))  # noqa: E501
        if "page" in params:
            query_params.append(("page", params["page"]))  # noqa: E501

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # Authentication setting
        auth_settings = []  # noqa: E501

        return self.api_client.call_api(
            "/exchanges/{id}/status_updates",
            "GET",
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type=None,  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get("async_req"),
            _return_http_data_only=params.get("_return_http_data_only"),
            _preload_content=params.get("_preload_content", True),
            _request_timeout=params.get("_request_timeout"),
            collection_formats=collection_formats,
        )

    def exchanges_id_tickers_get(self, id, **kwargs):  # noqa: E501
        """Get exchange tickers (paginated, 100 tickers per page)  # noqa: E501

        Get exchange tickers (paginated)<br><br> **IMPORTANT**:  Ticker `is_stale` is true when ticker that has not been updated/unchanged from the exchange for a while.  Ticker `is_anomaly` is true if ticker's price is outliered by our system.  You are responsible for managing how you want to display these information (e.g. footnote, different background, change opacity, hide)   # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.exchanges_id_tickers_get(id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str id: pass the exchange id (can be obtained from /exchanges/list) eg. binance (required)
        :param str coin_ids: filter tickers by coin_ids (ref: v3/coins/list)
        :param str include_exchange_logo: flag to show exchange_logo
        :param int page: Page through results
        :param str depth: flag to show 2% orderbook depth i.e., cost_to_move_up_usd and cost_to_move_down_usd
        :param str order: valid values: <b>trust_score_desc (default), trust_score_asc and volume_desc</b>
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs["_return_http_data_only"] = True
        if kwargs.get("async_req"):
            return self.exchanges_id_tickers_get_with_http_info(
                id, **kwargs
            )  # noqa: E501
        else:
            (data) = self.exchanges_id_tickers_get_with_http_info(
                id, **kwargs
            )  # noqa: E501
            return data

    def exchanges_id_tickers_get_with_http_info(self, id, **kwargs):  # noqa: E501
        """Get exchange tickers (paginated, 100 tickers per page)  # noqa: E501

        Get exchange tickers (paginated)<br><br> **IMPORTANT**:  Ticker `is_stale` is true when ticker that has not been updated/unchanged from the exchange for a while.  Ticker `is_anomaly` is true if ticker's price is outliered by our system.  You are responsible for managing how you want to display these information (e.g. footnote, different background, change opacity, hide)   # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.exchanges_id_tickers_get_with_http_info(id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str id: pass the exchange id (can be obtained from /exchanges/list) eg. binance (required)
        :param str coin_ids: filter tickers by coin_ids (ref: v3/coins/list)
        :param str include_exchange_logo: flag to show exchange_logo
        :param int page: Page through results
        :param str depth: flag to show 2% orderbook depth i.e., cost_to_move_up_usd and cost_to_move_down_usd
        :param str order: valid values: <b>trust_score_desc (default), trust_score_asc and volume_desc</b>
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = [
            "id",
            "coin_ids",
            "include_exchange_logo",
            "page",
            "depth",
            "order",
        ]  # noqa: E501
        all_params.append("async_req")
        all_params.append("_return_http_data_only")
        all_params.append("_preload_content")
        all_params.append("_request_timeout")

        params = locals()
        for key, val in six.iteritems(params["kwargs"]):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method exchanges_id_tickers_get" % key
                )
            params[key] = val
        del params["kwargs"]
        # verify the required parameter 'id' is set
        if "id" not in params or params["id"] is None:
            raise ValueError(
                "Missing the required parameter `id` when calling `exchanges_id_tickers_get`"
            )  # noqa: E501

        collection_formats = {}

        path_params = {}
        if "id" in params:
            path_params["id"] = params["id"]  # noqa: E501

        query_params = []
        if "coin_ids" in params:
            query_params.append(("coin_ids", params["coin_ids"]))  # noqa: E501
        if "include_exchange_logo" in params:
            query_params.append(
                ("include_exchange_logo", params["include_exchange_logo"])
            )  # noqa: E501
        if "page" in params:
            query_params.append(("page", params["page"]))  # noqa: E501
        if "depth" in params:
            query_params.append(("depth", params["depth"]))  # noqa: E501
        if "order" in params:
            query_params.append(("order", params["order"]))  # noqa: E501

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # Authentication setting
        auth_settings = []  # noqa: E501

        return self.api_client.call_api(
            "/exchanges/{id}/tickers",
            "GET",
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type=None,  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get("async_req"),
            _return_http_data_only=params.get("_return_http_data_only"),
            _preload_content=params.get("_preload_content", True),
            _request_timeout=params.get("_request_timeout"),
            collection_formats=collection_formats,
        )

    def exchanges_id_volume_chart_get(self, id, days, **kwargs):  # noqa: E501
        """Get volume_chart data for a given exchange  # noqa: E501

        Get volume_chart data for a given exchange  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.exchanges_id_volume_chart_get(id, days, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str id: pass the exchange id (can be obtained from /exchanges/list) eg. binance (required)
        :param int days:  Data up to number of days ago (eg. 1,14,30) (required)
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs["_return_http_data_only"] = True
        if kwargs.get("async_req"):
            return self.exchanges_id_volume_chart_get_with_http_info(
                id, days, **kwargs
            )  # noqa: E501
        else:
            (data) = self.exchanges_id_volume_chart_get_with_http_info(
                id, days, **kwargs
            )  # noqa: E501
            return data

    def exchanges_id_volume_chart_get_with_http_info(
        self, id, days, **kwargs
    ):  # noqa: E501
        """Get volume_chart data for a given exchange  # noqa: E501

        Get volume_chart data for a given exchange  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.exchanges_id_volume_chart_get_with_http_info(id, days, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str id: pass the exchange id (can be obtained from /exchanges/list) eg. binance (required)
        :param int days:  Data up to number of days ago (eg. 1,14,30) (required)
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ["id", "days"]  # noqa: E501
        all_params.append("async_req")
        all_params.append("_return_http_data_only")
        all_params.append("_preload_content")
        all_params.append("_request_timeout")

        params = locals()
        for key, val in six.iteritems(params["kwargs"]):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method exchanges_id_volume_chart_get" % key
                )
            params[key] = val
        del params["kwargs"]
        # verify the required parameter 'id' is set
        if "id" not in params or params["id"] is None:
            raise ValueError(
                "Missing the required parameter `id` when calling `exchanges_id_volume_chart_get`"
            )  # noqa: E501
        # verify the required parameter 'days' is set
        if "days" not in params or params["days"] is None:
            raise ValueError(
                "Missing the required parameter `days` when calling `exchanges_id_volume_chart_get`"
            )  # noqa: E501

        collection_formats = {}

        path_params = {}
        if "id" in params:
            path_params["id"] = params["id"]  # noqa: E501

        query_params = []
        if "days" in params:
            query_params.append(("days", params["days"]))  # noqa: E501

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # Authentication setting
        auth_settings = []  # noqa: E501

        return self.api_client.call_api(
            "/exchanges/{id}/volume_chart",
            "GET",
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type=None,  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get("async_req"),
            _return_http_data_only=params.get("_return_http_data_only"),
            _preload_content=params.get("_preload_content", True),
            _request_timeout=params.get("_request_timeout"),
            collection_formats=collection_formats,
        )

    def exchanges_list_get(self, **kwargs):  # noqa: E501
        """List all supported markets id and name (no pagination required)  # noqa: E501

        Use this to obtain all the markets' id in order to make API calls  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.exchanges_list_get(async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs["_return_http_data_only"] = True
        if kwargs.get("async_req"):
            return self.exchanges_list_get_with_http_info(**kwargs)  # noqa: E501
        else:
            (data) = self.exchanges_list_get_with_http_info(**kwargs)  # noqa: E501
            return data

    def exchanges_list_get_with_http_info(self, **kwargs):  # noqa: E501
        """List all supported markets id and name (no pagination required)  # noqa: E501

        Use this to obtain all the markets' id in order to make API calls  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.exchanges_list_get_with_http_info(async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = []  # noqa: E501
        all_params.append("async_req")
        all_params.append("_return_http_data_only")
        all_params.append("_preload_content")
        all_params.append("_request_timeout")

        params = locals()
        for key, val in six.iteritems(params["kwargs"]):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method exchanges_list_get" % key
                )
            params[key] = val
        del params["kwargs"]

        collection_formats = {}

        path_params = {}

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # Authentication setting
        auth_settings = []  # noqa: E501

        return self.api_client.call_api(
            "/exchanges/list",
            "GET",
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type=None,  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get("async_req"),
            _return_http_data_only=params.get("_return_http_data_only"),
            _preload_content=params.get("_preload_content", True),
            _request_timeout=params.get("_request_timeout"),
            collection_formats=collection_formats,
        )

    def finance_platforms_get(self, **kwargs):  # noqa: E501
        """List all finance platforms  # noqa: E501

        List all finance platforms  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.finance_platforms_get(async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param int per_page: Total results per page
        :param str page: page of results (paginated to 100 by default)
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs["_return_http_data_only"] = True
        if kwargs.get("async_req"):
            return self.finance_platforms_get_with_http_info(**kwargs)  # noqa: E501
        else:
            (data) = self.finance_platforms_get_with_http_info(**kwargs)  # noqa: E501
            return data

    def finance_platforms_get_with_http_info(self, **kwargs):  # noqa: E501
        """List all finance platforms  # noqa: E501

        List all finance platforms  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.finance_platforms_get_with_http_info(async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param int per_page: Total results per page
        :param str page: page of results (paginated to 100 by default)
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ["per_page", "page"]  # noqa: E501
        all_params.append("async_req")
        all_params.append("_return_http_data_only")
        all_params.append("_preload_content")
        all_params.append("_request_timeout")

        params = locals()
        for key, val in six.iteritems(params["kwargs"]):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method finance_platforms_get" % key
                )
            params[key] = val
        del params["kwargs"]

        collection_formats = {}

        path_params = {}

        query_params = []
        if "per_page" in params:
            query_params.append(("per_page", params["per_page"]))  # noqa: E501
        if "page" in params:
            query_params.append(("page", params["page"]))  # noqa: E501

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # Authentication setting
        auth_settings = []  # noqa: E501

        return self.api_client.call_api(
            "/finance_platforms",
            "GET",
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type=None,  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get("async_req"),
            _return_http_data_only=params.get("_return_http_data_only"),
            _preload_content=params.get("_preload_content", True),
            _request_timeout=params.get("_request_timeout"),
            collection_formats=collection_formats,
        )

    def finance_products_get(self, **kwargs):  # noqa: E501
        """List all finance products  # noqa: E501

        List all finance products  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.finance_products_get(async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param int per_page: Total results per page
        :param str page: page of results (paginated to 100 by default)
        :param str start_at: start date of the financial products
        :param str end_at: end date of the financial products
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs["_return_http_data_only"] = True
        if kwargs.get("async_req"):
            return self.finance_products_get_with_http_info(**kwargs)  # noqa: E501
        else:
            (data) = self.finance_products_get_with_http_info(**kwargs)  # noqa: E501
            return data

    def finance_products_get_with_http_info(self, **kwargs):  # noqa: E501
        """List all finance products  # noqa: E501

        List all finance products  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.finance_products_get_with_http_info(async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param int per_page: Total results per page
        :param str page: page of results (paginated to 100 by default)
        :param str start_at: start date of the financial products
        :param str end_at: end date of the financial products
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ["per_page", "page", "start_at", "end_at"]  # noqa: E501
        all_params.append("async_req")
        all_params.append("_return_http_data_only")
        all_params.append("_preload_content")
        all_params.append("_request_timeout")

        params = locals()
        for key, val in six.iteritems(params["kwargs"]):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method finance_products_get" % key
                )
            params[key] = val
        del params["kwargs"]

        collection_formats = {}

        path_params = {}

        query_params = []
        if "per_page" in params:
            query_params.append(("per_page", params["per_page"]))  # noqa: E501
        if "page" in params:
            query_params.append(("page", params["page"]))  # noqa: E501
        if "start_at" in params:
            query_params.append(("start_at", params["start_at"]))  # noqa: E501
        if "end_at" in params:
            query_params.append(("end_at", params["end_at"]))  # noqa: E501

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # Authentication setting
        auth_settings = []  # noqa: E501

        return self.api_client.call_api(
            "/finance_products",
            "GET",
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type=None,  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get("async_req"),
            _return_http_data_only=params.get("_return_http_data_only"),
            _preload_content=params.get("_preload_content", True),
            _request_timeout=params.get("_request_timeout"),
            collection_formats=collection_formats,
        )

    def global_decentralized_finance_defi_get(self, **kwargs):  # noqa: E501
        """Get cryptocurrency global decentralized finance(defi) data  # noqa: E501

        Get Top 100 Cryptocurrency Global Eecentralized Finance(defi) data   # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.global_decentralized_finance_defi_get(async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs["_return_http_data_only"] = True
        if kwargs.get("async_req"):
            return self.global_decentralized_finance_defi_get_with_http_info(
                **kwargs
            )  # noqa: E501
        else:
            (data) = self.global_decentralized_finance_defi_get_with_http_info(
                **kwargs
            )  # noqa: E501
            return data

    def global_decentralized_finance_defi_get_with_http_info(
        self, **kwargs
    ):  # noqa: E501
        """Get cryptocurrency global decentralized finance(defi) data  # noqa: E501

        Get Top 100 Cryptocurrency Global Eecentralized Finance(defi) data   # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.global_decentralized_finance_defi_get_with_http_info(async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = []  # noqa: E501
        all_params.append("async_req")
        all_params.append("_return_http_data_only")
        all_params.append("_preload_content")
        all_params.append("_request_timeout")

        params = locals()
        for key, val in six.iteritems(params["kwargs"]):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method global_decentralized_finance_defi_get" % key
                )
            params[key] = val
        del params["kwargs"]

        collection_formats = {}

        path_params = {}

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # Authentication setting
        auth_settings = []  # noqa: E501

        return self.api_client.call_api(
            "/global/decentralized_finance_defi",
            "GET",
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type=None,  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get("async_req"),
            _return_http_data_only=params.get("_return_http_data_only"),
            _preload_content=params.get("_preload_content", True),
            _request_timeout=params.get("_request_timeout"),
            collection_formats=collection_formats,
        )

    def global_get(self, **kwargs):  # noqa: E501
        """Get cryptocurrency global data  # noqa: E501

        Get cryptocurrency global data   # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.global_get(async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs["_return_http_data_only"] = True
        if kwargs.get("async_req"):
            return self.global_get_with_http_info(**kwargs)  # noqa: E501
        else:
            (data) = self.global_get_with_http_info(**kwargs)  # noqa: E501
            return data

    def global_get_with_http_info(self, **kwargs):  # noqa: E501
        """Get cryptocurrency global data  # noqa: E501

        Get cryptocurrency global data   # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.global_get_with_http_info(async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = []  # noqa: E501
        all_params.append("async_req")
        all_params.append("_return_http_data_only")
        all_params.append("_preload_content")
        all_params.append("_request_timeout")

        params = locals()
        for key, val in six.iteritems(params["kwargs"]):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method global_get" % key
                )
            params[key] = val
        del params["kwargs"]

        collection_formats = {}

        path_params = {}

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # Authentication setting
        auth_settings = []  # noqa: E501

        return self.api_client.call_api(
            "/global",
            "GET",
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type=None,  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get("async_req"),
            _return_http_data_only=params.get("_return_http_data_only"),
            _preload_content=params.get("_preload_content", True),
            _request_timeout=params.get("_request_timeout"),
            collection_formats=collection_formats,
        )

    def indexes_get(self, **kwargs):  # noqa: E501
        """List all market indexes  # noqa: E501

        List all market indexes  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.indexes_get(async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param int per_page: Total results per page
        :param int page: Page through results
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs["_return_http_data_only"] = True
        if kwargs.get("async_req"):
            return self.indexes_get_with_http_info(**kwargs)  # noqa: E501
        else:
            (data) = self.indexes_get_with_http_info(**kwargs)  # noqa: E501
            return data

    def indexes_get_with_http_info(self, **kwargs):  # noqa: E501
        """List all market indexes  # noqa: E501

        List all market indexes  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.indexes_get_with_http_info(async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param int per_page: Total results per page
        :param int page: Page through results
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ["per_page", "page"]  # noqa: E501
        all_params.append("async_req")
        all_params.append("_return_http_data_only")
        all_params.append("_preload_content")
        all_params.append("_request_timeout")

        params = locals()
        for key, val in six.iteritems(params["kwargs"]):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method indexes_get" % key
                )
            params[key] = val
        del params["kwargs"]

        collection_formats = {}

        path_params = {}

        query_params = []
        if "per_page" in params:
            query_params.append(("per_page", params["per_page"]))  # noqa: E501
        if "page" in params:
            query_params.append(("page", params["page"]))  # noqa: E501

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # Authentication setting
        auth_settings = []  # noqa: E501

        return self.api_client.call_api(
            "/indexes",
            "GET",
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type=None,  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get("async_req"),
            _return_http_data_only=params.get("_return_http_data_only"),
            _preload_content=params.get("_preload_content", True),
            _request_timeout=params.get("_request_timeout"),
            collection_formats=collection_formats,
        )

    def indexes_list_get(self, **kwargs):  # noqa: E501
        """list market indexes id and name  # noqa: E501

        list market indexes id and name  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.indexes_list_get(async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs["_return_http_data_only"] = True
        if kwargs.get("async_req"):
            return self.indexes_list_get_with_http_info(**kwargs)  # noqa: E501
        else:
            (data) = self.indexes_list_get_with_http_info(**kwargs)  # noqa: E501
            return data

    def indexes_list_get_with_http_info(self, **kwargs):  # noqa: E501
        """list market indexes id and name  # noqa: E501

        list market indexes id and name  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.indexes_list_get_with_http_info(async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = []  # noqa: E501
        all_params.append("async_req")
        all_params.append("_return_http_data_only")
        all_params.append("_preload_content")
        all_params.append("_request_timeout")

        params = locals()
        for key, val in six.iteritems(params["kwargs"]):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method indexes_list_get" % key
                )
            params[key] = val
        del params["kwargs"]

        collection_formats = {}

        path_params = {}

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # Authentication setting
        auth_settings = []  # noqa: E501

        return self.api_client.call_api(
            "/indexes/list",
            "GET",
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type=None,  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get("async_req"),
            _return_http_data_only=params.get("_return_http_data_only"),
            _preload_content=params.get("_preload_content", True),
            _request_timeout=params.get("_request_timeout"),
            collection_formats=collection_formats,
        )

    def indexes_market_id_id_get(self, market_id, id, **kwargs):  # noqa: E501
        """get market index by market id and index id  # noqa: E501

        get market index by market id and index id  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.indexes_market_id_id_get(market_id, id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str market_id: pass the market id (can be obtained from /exchanges/list) (required)
        :param str id: pass the index id (can be obtained from /indexes/list) (required)
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs["_return_http_data_only"] = True
        if kwargs.get("async_req"):
            return self.indexes_market_id_id_get_with_http_info(
                market_id, id, **kwargs
            )  # noqa: E501
        else:
            (data) = self.indexes_market_id_id_get_with_http_info(
                market_id, id, **kwargs
            )  # noqa: E501
            return data

    def indexes_market_id_id_get_with_http_info(
        self, market_id, id, **kwargs
    ):  # noqa: E501
        """get market index by market id and index id  # noqa: E501

        get market index by market id and index id  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.indexes_market_id_id_get_with_http_info(market_id, id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str market_id: pass the market id (can be obtained from /exchanges/list) (required)
        :param str id: pass the index id (can be obtained from /indexes/list) (required)
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ["market_id", "id"]  # noqa: E501
        all_params.append("async_req")
        all_params.append("_return_http_data_only")
        all_params.append("_preload_content")
        all_params.append("_request_timeout")

        params = locals()
        for key, val in six.iteritems(params["kwargs"]):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method indexes_market_id_id_get" % key
                )
            params[key] = val
        del params["kwargs"]
        # verify the required parameter 'market_id' is set
        if "market_id" not in params or params["market_id"] is None:
            raise ValueError(
                "Missing the required parameter `market_id` when calling `indexes_market_id_id_get`"
            )  # noqa: E501
        # verify the required parameter 'id' is set
        if "id" not in params or params["id"] is None:
            raise ValueError(
                "Missing the required parameter `id` when calling `indexes_market_id_id_get`"
            )  # noqa: E501

        collection_formats = {}

        path_params = {}
        if "market_id" in params:
            path_params["market_id"] = params["market_id"]  # noqa: E501
        if "id" in params:
            path_params["id"] = params["id"]  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # Authentication setting
        auth_settings = []  # noqa: E501

        return self.api_client.call_api(
            "/indexes/{market_id}/{id}",
            "GET",
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type=None,  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get("async_req"),
            _return_http_data_only=params.get("_return_http_data_only"),
            _preload_content=params.get("_preload_content", True),
            _request_timeout=params.get("_request_timeout"),
            collection_formats=collection_formats,
        )

    def ping_get(self, **kwargs):  # noqa: E501
        """Check API server status  # noqa: E501

        Check API server status   # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.ping_get(async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs["_return_http_data_only"] = True
        if kwargs.get("async_req"):
            return self.ping_get_with_http_info(**kwargs)  # noqa: E501
        else:
            (data) = self.ping_get_with_http_info(**kwargs)  # noqa: E501
            return data

    def ping_get_with_http_info(self, **kwargs):  # noqa: E501
        """Check API server status  # noqa: E501

        Check API server status   # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.ping_get_with_http_info(async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = []  # noqa: E501
        all_params.append("async_req")
        all_params.append("_return_http_data_only")
        all_params.append("_preload_content")
        all_params.append("_request_timeout")

        params = locals()
        for key, val in six.iteritems(params["kwargs"]):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method ping_get" % key
                )
            params[key] = val
        del params["kwargs"]

        collection_formats = {}

        path_params = {}

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # Authentication setting
        auth_settings = []  # noqa: E501

        return self.api_client.call_api(
            "/ping",
            "GET",
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type=None,  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get("async_req"),
            _return_http_data_only=params.get("_return_http_data_only"),
            _preload_content=params.get("_preload_content", True),
            _request_timeout=params.get("_request_timeout"),
            collection_formats=collection_formats,
        )

    def search_get(self, query, **kwargs):  # noqa: E501
        """Search for coins, categories and markets on CoinGecko  # noqa: E501

        Search for coins, categories and markets listed on CoinGecko ordered by largest Market Cap first  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.search_get(query, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str query: Search string (required)
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs["_return_http_data_only"] = True
        if kwargs.get("async_req"):
            return self.search_get_with_http_info(query, **kwargs)  # noqa: E501
        else:
            (data) = self.search_get_with_http_info(query, **kwargs)  # noqa: E501
            return data

    def search_get_with_http_info(self, query, **kwargs):  # noqa: E501
        """Search for coins, categories and markets on CoinGecko  # noqa: E501

        Search for coins, categories and markets listed on CoinGecko ordered by largest Market Cap first  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.search_get_with_http_info(query, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str query: Search string (required)
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ["query"]  # noqa: E501
        all_params.append("async_req")
        all_params.append("_return_http_data_only")
        all_params.append("_preload_content")
        all_params.append("_request_timeout")

        params = locals()
        for key, val in six.iteritems(params["kwargs"]):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method search_get" % key
                )
            params[key] = val
        del params["kwargs"]
        # verify the required parameter 'query' is set
        if "query" not in params or params["query"] is None:
            raise ValueError(
                "Missing the required parameter `query` when calling `search_get`"
            )  # noqa: E501

        collection_formats = {}

        path_params = {}

        query_params = []
        if "query" in params:
            query_params.append(("query", params["query"]))  # noqa: E501

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # Authentication setting
        auth_settings = []  # noqa: E501

        return self.api_client.call_api(
            "/search",
            "GET",
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type=None,  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get("async_req"),
            _return_http_data_only=params.get("_return_http_data_only"),
            _preload_content=params.get("_preload_content", True),
            _request_timeout=params.get("_request_timeout"),
            collection_formats=collection_formats,
        )

    def search_trending_get(self, **kwargs):  # noqa: E501
        """Get trending search coins (Top-7) on CoinGecko in the last 24 hours  # noqa: E501

        Top-7 trending coins on CoinGecko as searched by users in the last 24 hours (Ordered by most popular first)  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.search_trending_get(async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs["_return_http_data_only"] = True
        if kwargs.get("async_req"):
            return self.search_trending_get_with_http_info(**kwargs)  # noqa: E501
        else:
            (data) = self.search_trending_get_with_http_info(**kwargs)  # noqa: E501
            return data

    def search_trending_get_with_http_info(self, **kwargs):  # noqa: E501
        """Get trending search coins (Top-7) on CoinGecko in the last 24 hours  # noqa: E501

        Top-7 trending coins on CoinGecko as searched by users in the last 24 hours (Ordered by most popular first)  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.search_trending_get_with_http_info(async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = []  # noqa: E501
        all_params.append("async_req")
        all_params.append("_return_http_data_only")
        all_params.append("_preload_content")
        all_params.append("_request_timeout")

        params = locals()
        for key, val in six.iteritems(params["kwargs"]):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method search_trending_get" % key
                )
            params[key] = val
        del params["kwargs"]

        collection_formats = {}

        path_params = {}

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # Authentication setting
        auth_settings = []  # noqa: E501

        return self.api_client.call_api(
            "/search/trending",
            "GET",
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type=None,  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get("async_req"),
            _return_http_data_only=params.get("_return_http_data_only"),
            _preload_content=params.get("_preload_content", True),
            _request_timeout=params.get("_request_timeout"),
            collection_formats=collection_formats,
        )

    def simple_price_get(self, ids, vs_currencies, **kwargs):  # noqa: E501
        """Get the current price of any cryptocurrencies in any other supported currencies that you need.  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.simple_price_get(ids, vs_currencies, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str ids: id of coins, comma-separated if querying more than 1 coin *refers to <b>`coins/list`</b> (required)
        :param str vs_currencies: vs_currency of coins, comma-separated if querying more than 1 vs_currency *refers to <b>`simple/supported_vs_currencies`</b> (required)
        :param str include_market_cap: <b>true/false</b> to include market_cap, <b>default: false</b>
        :param str include_24hr_vol: <b>true/false</b> to include 24hr_vol, <b>default: false</b>
        :param str include_24hr_change: <b>true/false</b> to include 24hr_change, <b>default: false</b>
        :param str include_last_updated_at: <b>true/false</b> to include last_updated_at of price, <b>default: false</b>
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs["_return_http_data_only"] = True
        if kwargs.get("async_req"):
            return self.simple_price_get_with_http_info(
                ids, vs_currencies, **kwargs
            )  # noqa: E501
        else:
            (data) = self.simple_price_get_with_http_info(
                ids, vs_currencies, **kwargs
            )  # noqa: E501
            return data

    def simple_price_get_with_http_info(
        self, ids, vs_currencies, **kwargs
    ):  # noqa: E501
        """Get the current price of any cryptocurrencies in any other supported currencies that you need.  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.simple_price_get_with_http_info(ids, vs_currencies, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str ids: id of coins, comma-separated if querying more than 1 coin *refers to <b>`coins/list`</b> (required)
        :param str vs_currencies: vs_currency of coins, comma-separated if querying more than 1 vs_currency *refers to <b>`simple/supported_vs_currencies`</b> (required)
        :param str include_market_cap: <b>true/false</b> to include market_cap, <b>default: false</b>
        :param str include_24hr_vol: <b>true/false</b> to include 24hr_vol, <b>default: false</b>
        :param str include_24hr_change: <b>true/false</b> to include 24hr_change, <b>default: false</b>
        :param str include_last_updated_at: <b>true/false</b> to include last_updated_at of price, <b>default: false</b>
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = [
            "ids",
            "vs_currencies",
            "include_market_cap",
            "include_24hr_vol",
            "include_24hr_change",
            "include_last_updated_at",
        ]  # noqa: E501
        all_params.append("async_req")
        all_params.append("_return_http_data_only")
        all_params.append("_preload_content")
        all_params.append("_request_timeout")

        params = locals()
        for key, val in six.iteritems(params["kwargs"]):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method simple_price_get" % key
                )
            params[key] = val
        del params["kwargs"]
        # verify the required parameter 'ids' is set
        if "ids" not in params or params["ids"] is None:
            raise ValueError(
                "Missing the required parameter `ids` when calling `simple_price_get`"
            )  # noqa: E501
        # verify the required parameter 'vs_currencies' is set
        if "vs_currencies" not in params or params["vs_currencies"] is None:
            raise ValueError(
                "Missing the required parameter `vs_currencies` when calling `simple_price_get`"
            )  # noqa: E501

        collection_formats = {}

        path_params = {}

        query_params = []
        if "ids" in params:
            query_params.append(("ids", params["ids"]))  # noqa: E501
        if "vs_currencies" in params:
            query_params.append(
                ("vs_currencies", params["vs_currencies"])
            )  # noqa: E501
        if "include_market_cap" in params:
            query_params.append(
                ("include_market_cap", params["include_market_cap"])
            )  # noqa: E501
        if "include_24hr_vol" in params:
            query_params.append(
                ("include_24hr_vol", params["include_24hr_vol"])
            )  # noqa: E501
        if "include_24hr_change" in params:
            query_params.append(
                ("include_24hr_change", params["include_24hr_change"])
            )  # noqa: E501
        if "include_last_updated_at" in params:
            query_params.append(
                ("include_last_updated_at", params["include_last_updated_at"])
            )  # noqa: E501

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # Authentication setting
        auth_settings = []  # noqa: E501

        return self.api_client.call_api(
            "/simple/price",
            "GET",
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type=None,  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get("async_req"),
            _return_http_data_only=params.get("_return_http_data_only"),
            _preload_content=params.get("_preload_content", True),
            _request_timeout=params.get("_request_timeout"),
            collection_formats=collection_formats,
        )

    def simple_supported_vs_currencies_get(self, **kwargs):  # noqa: E501
        """Get list of supported_vs_currencies.  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.simple_supported_vs_currencies_get(async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs["_return_http_data_only"] = True
        if kwargs.get("async_req"):
            return self.simple_supported_vs_currencies_get_with_http_info(
                **kwargs
            )  # noqa: E501
        else:
            (data) = self.simple_supported_vs_currencies_get_with_http_info(
                **kwargs
            )  # noqa: E501
            return data

    def simple_supported_vs_currencies_get_with_http_info(self, **kwargs):  # noqa: E501
        """Get list of supported_vs_currencies.  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.simple_supported_vs_currencies_get_with_http_info(async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = []  # noqa: E501
        all_params.append("async_req")
        all_params.append("_return_http_data_only")
        all_params.append("_preload_content")
        all_params.append("_request_timeout")

        params = locals()
        for key, val in six.iteritems(params["kwargs"]):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method simple_supported_vs_currencies_get" % key
                )
            params[key] = val
        del params["kwargs"]

        collection_formats = {}

        path_params = {}

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # Authentication setting
        auth_settings = []  # noqa: E501

        return self.api_client.call_api(
            "/simple/supported_vs_currencies",
            "GET",
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type=None,  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get("async_req"),
            _return_http_data_only=params.get("_return_http_data_only"),
            _preload_content=params.get("_preload_content", True),
            _request_timeout=params.get("_request_timeout"),
            collection_formats=collection_formats,
        )

    def simple_token_price_id_get(
        self, id, contract_addresses, vs_currencies, **kwargs
    ):  # noqa: E501
        """Get current price of tokens (using contract addresses) for a given platform in any other currency that you need.  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.simple_token_price_id_get(id, contract_addresses, vs_currencies, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str id: The id of the platform issuing tokens (See asset_platforms endpoint for list of options) (required)
        :param str contract_addresses: The contract address of tokens, comma separated (required)
        :param str vs_currencies: vs_currency of coins, comma-separated if querying more than 1 vs_currency *refers to <b>`simple/supported_vs_currencies`</b> (required)
        :param str include_market_cap: <b>true/false</b> to include market_cap, <b>default: false</b>
        :param str include_24hr_vol: <b>true/false</b> to include 24hr_vol, <b>default: false</b>
        :param str include_24hr_change: <b>true/false</b> to include 24hr_change, <b>default: false</b>
        :param str include_last_updated_at: <b>true/false</b> to include last_updated_at of price, <b>default: false</b>
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs["_return_http_data_only"] = True
        if kwargs.get("async_req"):
            return self.simple_token_price_id_get_with_http_info(
                id, contract_addresses, vs_currencies, **kwargs
            )  # noqa: E501
        else:
            (data) = self.simple_token_price_id_get_with_http_info(
                id, contract_addresses, vs_currencies, **kwargs
            )  # noqa: E501
            return data

    def simple_token_price_id_get_with_http_info(
        self, id, contract_addresses, vs_currencies, **kwargs
    ):  # noqa: E501
        """Get current price of tokens (using contract addresses) for a given platform in any other currency that you need.  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.simple_token_price_id_get_with_http_info(id, contract_addresses, vs_currencies, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str id: The id of the platform issuing tokens (See asset_platforms endpoint for list of options) (required)
        :param str contract_addresses: The contract address of tokens, comma separated (required)
        :param str vs_currencies: vs_currency of coins, comma-separated if querying more than 1 vs_currency *refers to <b>`simple/supported_vs_currencies`</b> (required)
        :param str include_market_cap: <b>true/false</b> to include market_cap, <b>default: false</b>
        :param str include_24hr_vol: <b>true/false</b> to include 24hr_vol, <b>default: false</b>
        :param str include_24hr_change: <b>true/false</b> to include 24hr_change, <b>default: false</b>
        :param str include_last_updated_at: <b>true/false</b> to include last_updated_at of price, <b>default: false</b>
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = [
            "id",
            "contract_addresses",
            "vs_currencies",
            "include_market_cap",
            "include_24hr_vol",
            "include_24hr_change",
            "include_last_updated_at",
        ]  # noqa: E501
        all_params.append("async_req")
        all_params.append("_return_http_data_only")
        all_params.append("_preload_content")
        all_params.append("_request_timeout")

        params = locals()
        for key, val in six.iteritems(params["kwargs"]):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method simple_token_price_id_get" % key
                )
            params[key] = val
        del params["kwargs"]
        # verify the required parameter 'id' is set
        if "id" not in params or params["id"] is None:
            raise ValueError(
                "Missing the required parameter `id` when calling `simple_token_price_id_get`"
            )  # noqa: E501
        # verify the required parameter 'contract_addresses' is set
        if "contract_addresses" not in params or params["contract_addresses"] is None:
            raise ValueError(
                "Missing the required parameter `contract_addresses` when calling `simple_token_price_id_get`"
            )  # noqa: E501
        # verify the required parameter 'vs_currencies' is set
        if "vs_currencies" not in params or params["vs_currencies"] is None:
            raise ValueError(
                "Missing the required parameter `vs_currencies` when calling `simple_token_price_id_get`"
            )  # noqa: E501

        collection_formats = {}

        path_params = {}
        if "id" in params:
            path_params["id"] = params["id"]  # noqa: E501

        query_params = []
        if "contract_addresses" in params:
            query_params.append(
                ("contract_addresses", params["contract_addresses"])
            )  # noqa: E501
        if "vs_currencies" in params:
            query_params.append(
                ("vs_currencies", params["vs_currencies"])
            )  # noqa: E501
        if "include_market_cap" in params:
            query_params.append(
                ("include_market_cap", params["include_market_cap"])
            )  # noqa: E501
        if "include_24hr_vol" in params:
            query_params.append(
                ("include_24hr_vol", params["include_24hr_vol"])
            )  # noqa: E501
        if "include_24hr_change" in params:
            query_params.append(
                ("include_24hr_change", params["include_24hr_change"])
            )  # noqa: E501
        if "include_last_updated_at" in params:
            query_params.append(
                ("include_last_updated_at", params["include_last_updated_at"])
            )  # noqa: E501

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # Authentication setting
        auth_settings = []  # noqa: E501

        return self.api_client.call_api(
            "/simple/token_price/{id}",
            "GET",
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type=None,  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get("async_req"),
            _return_http_data_only=params.get("_return_http_data_only"),
            _preload_content=params.get("_preload_content", True),
            _request_timeout=params.get("_request_timeout"),
            collection_formats=collection_formats,
        )

    def status_updates_get(self, **kwargs):  # noqa: E501
        """List all status_updates with data (description, category, created_at, user, user_title and pin)  # noqa: E501

        List all status_updates with data (description, category, created_at, user, user_title and pin)   # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.status_updates_get(async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str category: Filtered by category (eg. general, milestone, partnership, exchange_listing, software_release, fund_movement, new_listings, event)
        :param str project_type: Filtered by Project Type (eg. coin, market). If left empty returns both status from coins and markets.
        :param int per_page: Total results per page
        :param int page: Page through results
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs["_return_http_data_only"] = True
        if kwargs.get("async_req"):
            return self.status_updates_get_with_http_info(**kwargs)  # noqa: E501
        else:
            (data) = self.status_updates_get_with_http_info(**kwargs)  # noqa: E501
            return data

    def status_updates_get_with_http_info(self, **kwargs):  # noqa: E501
        """List all status_updates with data (description, category, created_at, user, user_title and pin)  # noqa: E501

        List all status_updates with data (description, category, created_at, user, user_title and pin)   # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.status_updates_get_with_http_info(async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str category: Filtered by category (eg. general, milestone, partnership, exchange_listing, software_release, fund_movement, new_listings, event)
        :param str project_type: Filtered by Project Type (eg. coin, market). If left empty returns both status from coins and markets.
        :param int per_page: Total results per page
        :param int page: Page through results
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ["category", "project_type", "per_page", "page"]  # noqa: E501
        all_params.append("async_req")
        all_params.append("_return_http_data_only")
        all_params.append("_preload_content")
        all_params.append("_request_timeout")

        params = locals()
        for key, val in six.iteritems(params["kwargs"]):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method status_updates_get" % key
                )
            params[key] = val
        del params["kwargs"]

        collection_formats = {}

        path_params = {}

        query_params = []
        if "category" in params:
            query_params.append(("category", params["category"]))  # noqa: E501
        if "project_type" in params:
            query_params.append(("project_type", params["project_type"]))  # noqa: E501
        if "per_page" in params:
            query_params.append(("per_page", params["per_page"]))  # noqa: E501
        if "page" in params:
            query_params.append(("page", params["page"]))  # noqa: E501

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # Authentication setting
        auth_settings = []  # noqa: E501

        return self.api_client.call_api(
            "/status_updates",
            "GET",
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type=None,  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get("async_req"),
            _return_http_data_only=params.get("_return_http_data_only"),
            _preload_content=params.get("_preload_content", True),
            _request_timeout=params.get("_request_timeout"),
            collection_formats=collection_formats,
        )
