import e from"/static/@ruteni/quotquot/v1/espression.js";import t from"/static/@ruteni/logging/v1/index.js";const s=t.getLogger("@quotquot/template");var r=[class extends n{static renderElement(e,t,s,r,n,i){for(const a of e.attributes)this.renderAttribute(a,t,s,r,n,i)}static renderAttribute(e,t,s,r,n,i){("data-expr"===e.name||e.name.startsWith("data-expr-"))&&this.getOrCreateRenderer(e,i).update(e,t,s,r,n)}constructor(t,s){super(s),this.ast=e.parse(t.value),this.vars=e.variables(this.ast)}intersects(e){return i(e,this.vars)}renderElement(t,s,r,n,i){const a=e.evaluate(this.ast,r),o=t.ownerElement,l=t.name;let d;9===l.length?(d=document.createTextNode(a),o.appendChild(d)):(d=document.createAttribute(l.slice(10)),d.value=a,o.setAttributeNode(d),s._renderAttribute(d,r,n,i,this)),this.nodes.add(d)}},class extends o{constructor(e,t){super(t);const s=e.ownerElement,r=s.nextElementSibling;a(r)&&r.hasAttribute("data-else")?this.elseTemplate=this.lastTemplate=r:this.lastTemplate=s;let n="item",i="index",o=parse(e.value);if("Identifier"===o.type||"MemberExpression"===o.type);else if("BinaryExpression"===o.type&&"in"===o.operator&&"Identifier"===o.left.type)n=o.left.name,o=o.right;else{if("Compound"!==o.type||"Identifier"!==o.body[0].type||"BinaryExpression"!==o.body[1].type||"in"!==o.body[1].operator||"Identifier"!==o.body[1].left.type)throw new Error(`invalid foreach expression "${e.value}"`);n=o.body[0].name,i=o.body[1].left.name,o=o.body[1].right}this.ast=o,this.vars=variables(o),this.itemName=n,this.indexName=i}intersects(e){return i(e,this.vars)}renderElement(e,t,r,n,i){const a=evaluate(this.ast,r);if(Array.isArray(a))if(a.length){let s;const o={},l=Object.assign({forloop:o},i),d=e.ownerElement;for(let e=0;e<a.length;++e)l[this.itemName]=a[e],l[this.indexName]=e,o.first=0===e,o.last=e===a.length-1,s=this.instantiate(t,r,n,l,d,s)}else this.elseTemplate&&this.instantiate(t,r,n,i,this.elseTemplate);else s.warn("foreach expression is not an array",a)}},class extends o{constructor(e,t){super(t),this.branches=new Map;let s=this.addBranch(e.ownerElement,e);for(;s;){if(!(e=s.getAttributeNode("data-else-if")))return void(s.getAttributeNode("data-else")&&(this.elseTemplate=this.lastTemplate=s));s=this.addBranch(s,e)}}addBranch(e,t){const s=parse(t.value);this.branches.set(e,{ast:s,vars:variables(s)}),this.lastTemplate=e;const r=e.nextElementSibling;return a(r)?r:null}intersects(e){for(const{vars:t}of this.branches.values())if(i(e,t))return!0;return!1}renderElement(e,t,s,r,n){for(const[e,{ast:i}]of this.branches.entries())if(evaluate(i,s))return void this.instantiate(t,s,r,n,e);this.elseTemplate&&this.instantiate(t,s,r,n,this.elseTemplate)}}];class n{static getOrCreateRenderer(e,t){return e.renderer||(e.renderer=new this(e,t)),e.renderer}constructor(e){this.children=new Set,e&&e.children.add(this)}update(e,t,s,r,n){if(!this.nodes||this.intersects(r))this.nodes?this.clear():this.nodes=new Set,this.renderElement(e,t,s,r,n);else for(const i of this.children)i.update(e,t,s,r,n)}clear(){for(const e of this.children)e.clear();this.children.clear();for(const e of this.nodes)e.nodeType===Node.ATTRIBUTE_NODE?e.ownerElement.removeAttributeNode(e):e.remove();this.nodes.clear()}}const i=(e,t)=>e.some((e=>t.has(e))),a=e=>e instanceof HTMLTemplateElement;class o extends n{static renderElement(e,t,s,r,n,i){if(a(e)){const a=e.getAttributeNode(`data-${this.name}`);a&&this.getOrCreateRenderer(a,i).update(a,t,s,r,n)}}instantiate(e,t,s,r,n,i){const a=n.content.cloneNode(!0);let o;for(o of(e._renderSubtree(a,t,s,r,this),a.children))this.nodes.add(o),o.renderedBy=this,o.renderedFrom=n;return i||(i=this.lastTemplate),i.parentNode.insertBefore(a,i.nextSibling),o}}export{r as default};
