import e from"/static/@ruteni/logging/v1/index.js";var t={exports:{}};!function(e){var t=Object.prototype.hasOwnProperty,r="~";function n(){}function i(e,t,r){this.fn=e,this.context=t,this.once=r||!1}function s(e,t,n,s,o){if("function"!=typeof n)throw new TypeError("The listener must be a function");var a=new i(n,s||e,o),u=r?r+t:t;return e._events[u]?e._events[u].fn?e._events[u]=[e._events[u],a]:e._events[u].push(a):(e._events[u]=a,e._eventsCount++),e}function o(e,t){0==--e._eventsCount?e._events=new n:delete e._events[t]}function a(){this._events=new n,this._eventsCount=0}Object.create&&(n.prototype=Object.create(null),(new n).__proto__||(r=!1)),a.prototype.eventNames=function(){var e,n,i=[];if(0===this._eventsCount)return i;for(n in e=this._events)t.call(e,n)&&i.push(r?n.slice(1):n);return Object.getOwnPropertySymbols?i.concat(Object.getOwnPropertySymbols(e)):i},a.prototype.listeners=function(e){var t=r?r+e:e,n=this._events[t];if(!n)return[];if(n.fn)return[n.fn];for(var i=0,s=n.length,o=new Array(s);i<s;i++)o[i]=n[i].fn;return o},a.prototype.listenerCount=function(e){var t=r?r+e:e,n=this._events[t];return n?n.fn?1:n.length:0},a.prototype.emit=function(e,t,n,i,s,o){var a=r?r+e:e;if(!this._events[a])return!1;var u,l,c=this._events[a],h=arguments.length;if(c.fn){switch(c.once&&this.removeListener(e,c.fn,void 0,!0),h){case 1:return c.fn.call(c.context),!0;case 2:return c.fn.call(c.context,t),!0;case 3:return c.fn.call(c.context,t,n),!0;case 4:return c.fn.call(c.context,t,n,i),!0;case 5:return c.fn.call(c.context,t,n,i,s),!0;case 6:return c.fn.call(c.context,t,n,i,s,o),!0}for(l=1,u=new Array(h-1);l<h;l++)u[l-1]=arguments[l];c.fn.apply(c.context,u)}else{var d,v=c.length;for(l=0;l<v;l++)switch(c[l].once&&this.removeListener(e,c[l].fn,void 0,!0),h){case 1:c[l].fn.call(c[l].context);break;case 2:c[l].fn.call(c[l].context,t);break;case 3:c[l].fn.call(c[l].context,t,n);break;case 4:c[l].fn.call(c[l].context,t,n,i);break;default:if(!u)for(d=1,u=new Array(h-1);d<h;d++)u[d-1]=arguments[d];c[l].fn.apply(c[l].context,u)}}return!0},a.prototype.on=function(e,t,r){return s(this,e,t,r,!1)},a.prototype.once=function(e,t,r){return s(this,e,t,r,!0)},a.prototype.removeListener=function(e,t,n,i){var s=r?r+e:e;if(!this._events[s])return this;if(!t)return o(this,s),this;var a=this._events[s];if(a.fn)a.fn!==t||i&&!a.once||n&&a.context!==n||o(this,s);else{for(var u=0,l=[],c=a.length;u<c;u++)(a[u].fn!==t||i&&!a[u].once||n&&a[u].context!==n)&&l.push(a[u]);l.length?this._events[s]=1===l.length?l[0]:l:o(this,s)}return this},a.prototype.removeAllListeners=function(e){var t;return e?(t=r?r+e:e,this._events[t]&&o(this,t)):(this._events=new n,this._eventsCount=0),this},a.prototype.off=a.prototype.removeListener,a.prototype.addListener=a.prototype.on,a.prefixed=r,a.EventEmitter=a,e.exports=a}(t);var r=t.exports;class n extends Error{constructor(e){super(e),this.name="TimeoutError"}}class i{constructor(){Object.defineProperty(this,"_queue",{enumerable:!0,configurable:!0,writable:!0,value:[]})}enqueue(e,t){var r;const n={priority:(t={priority:0,...t}).priority,run:e};if(this.size&&(null===(r=this._queue[this.size-1])||void 0===r?void 0:r.priority)>=t.priority)return void this._queue.push(n);const i=function(e,t,r){let n=0,i=e.length;for(;i>0;){const s=Math.trunc(i/2);let o=n+s;r(e[o],t)<=0?(n=++o,i-=s+1):i=s}return n}(this._queue,n,((e,t)=>t.priority-e.priority));this._queue.splice(i,0,n)}dequeue(){const e=this._queue.shift();return null==e?void 0:e.run}filter(e){return this._queue.filter((t=>t.priority===e.priority)).map((e=>e.run))}get size(){return this._queue.length}}const s=()=>{},o=new n;class a extends r{constructor(e){var t,r,n,o;if(super(),Object.defineProperty(this,"_carryoverConcurrencyCount",{enumerable:!0,configurable:!0,writable:!0,value:void 0}),Object.defineProperty(this,"_isIntervalIgnored",{enumerable:!0,configurable:!0,writable:!0,value:void 0}),Object.defineProperty(this,"_intervalCount",{enumerable:!0,configurable:!0,writable:!0,value:0}),Object.defineProperty(this,"_intervalCap",{enumerable:!0,configurable:!0,writable:!0,value:void 0}),Object.defineProperty(this,"_interval",{enumerable:!0,configurable:!0,writable:!0,value:void 0}),Object.defineProperty(this,"_intervalEnd",{enumerable:!0,configurable:!0,writable:!0,value:0}),Object.defineProperty(this,"_intervalId",{enumerable:!0,configurable:!0,writable:!0,value:void 0}),Object.defineProperty(this,"_timeoutId",{enumerable:!0,configurable:!0,writable:!0,value:void 0}),Object.defineProperty(this,"_queue",{enumerable:!0,configurable:!0,writable:!0,value:void 0}),Object.defineProperty(this,"_queueClass",{enumerable:!0,configurable:!0,writable:!0,value:void 0}),Object.defineProperty(this,"_pendingCount",{enumerable:!0,configurable:!0,writable:!0,value:0}),Object.defineProperty(this,"_concurrency",{enumerable:!0,configurable:!0,writable:!0,value:void 0}),Object.defineProperty(this,"_isPaused",{enumerable:!0,configurable:!0,writable:!0,value:void 0}),Object.defineProperty(this,"_resolveEmpty",{enumerable:!0,configurable:!0,writable:!0,value:s}),Object.defineProperty(this,"_resolveIdle",{enumerable:!0,configurable:!0,writable:!0,value:s}),Object.defineProperty(this,"_timeout",{enumerable:!0,configurable:!0,writable:!0,value:void 0}),Object.defineProperty(this,"_throwOnTimeout",{enumerable:!0,configurable:!0,writable:!0,value:void 0}),!("number"==typeof(e={carryoverConcurrencyCount:!1,intervalCap:Number.POSITIVE_INFINITY,interval:0,concurrency:Number.POSITIVE_INFINITY,autoStart:!0,queueClass:i,...e}).intervalCap&&e.intervalCap>=1))throw new TypeError(`Expected \`intervalCap\` to be a number from 1 and up, got \`${null!==(r=null===(t=e.intervalCap)||void 0===t?void 0:t.toString())&&void 0!==r?r:""}\` (${typeof e.intervalCap})`);if(void 0===e.interval||!(Number.isFinite(e.interval)&&e.interval>=0))throw new TypeError(`Expected \`interval\` to be a finite number >= 0, got \`${null!==(o=null===(n=e.interval)||void 0===n?void 0:n.toString())&&void 0!==o?o:""}\` (${typeof e.interval})`);this._carryoverConcurrencyCount=e.carryoverConcurrencyCount,this._isIntervalIgnored=e.intervalCap===Number.POSITIVE_INFINITY||0===e.interval,this._intervalCap=e.intervalCap,this._interval=e.interval,this._queue=new e.queueClass,this._queueClass=e.queueClass,this.concurrency=e.concurrency,this._timeout=e.timeout,this._throwOnTimeout=!0===e.throwOnTimeout,this._isPaused=!1===e.autoStart}get _doesIntervalAllowAnother(){return this._isIntervalIgnored||this._intervalCount<this._intervalCap}get _doesConcurrentAllowAnother(){return this._pendingCount<this._concurrency}_next(){this._pendingCount--,this._tryToStartAnother(),this.emit("next")}_resolvePromises(){this._resolveEmpty(),this._resolveEmpty=s,0===this._pendingCount&&(this._resolveIdle(),this._resolveIdle=s,this.emit("idle"))}_onResumeInterval(){this._onInterval(),this._initializeIntervalIfNeeded(),this._timeoutId=void 0}_isIntervalPaused(){const e=Date.now();if(void 0===this._intervalId){const t=this._intervalEnd-e;if(!(t<0))return void 0===this._timeoutId&&(this._timeoutId=setTimeout((()=>{this._onResumeInterval()}),t)),!0;this._intervalCount=this._carryoverConcurrencyCount?this._pendingCount:0}return!1}_tryToStartAnother(){if(0===this._queue.size)return this._intervalId&&clearInterval(this._intervalId),this._intervalId=void 0,this._resolvePromises(),!1;if(!this._isPaused){const e=!this._isIntervalPaused();if(this._doesIntervalAllowAnother&&this._doesConcurrentAllowAnother){const t=this._queue.dequeue();return!!t&&(this.emit("active"),t(),e&&this._initializeIntervalIfNeeded(),!0)}}return!1}_initializeIntervalIfNeeded(){this._isIntervalIgnored||void 0!==this._intervalId||(this._intervalId=setInterval((()=>{this._onInterval()}),this._interval),this._intervalEnd=Date.now()+this._interval)}_onInterval(){0===this._intervalCount&&0===this._pendingCount&&this._intervalId&&(clearInterval(this._intervalId),this._intervalId=void 0),this._intervalCount=this._carryoverConcurrencyCount?this._pendingCount:0,this._processQueue()}_processQueue(){for(;this._tryToStartAnother(););}get concurrency(){return this._concurrency}set concurrency(e){if(!("number"==typeof e&&e>=1))throw new TypeError(`Expected \`concurrency\` to be a number from 1 and up, got \`${e}\` (${typeof e})`);this._concurrency=e,this._processQueue()}async add(e,t={}){return new Promise(((r,n)=>{this._queue.enqueue((async()=>{this._pendingCount++,this._intervalCount++;try{const i=void 0===this._timeout&&void 0===t.timeout?e():function(e,t,r,n){let i;const s=new Promise(((s,o)=>{if("number"!=typeof t||t<0)throw new TypeError("Expected `milliseconds` to be a positive number");t!==Number.POSITIVE_INFINITY?(n={customTimers:{setTimeout:setTimeout,clearTimeout:clearTimeout},...n},i=n.customTimers.setTimeout.call(void 0,(()=>{try{s(r())}catch(e){o(e)}}),t),(async()=>{try{s(await e)}catch(e){o(e)}finally{n.customTimers.clearTimeout.call(void 0,i)}})()):s(e)}));return s.clear=()=>{clearTimeout(i),i=void 0},s}(Promise.resolve(e()),void 0===t.timeout?this._timeout:t.timeout,(()=>{(void 0===t.throwOnTimeout?this._throwOnTimeout:t.throwOnTimeout)&&n(o)})),s=await i;r(s),this.emit("completed",s)}catch(e){n(e),this.emit("error",e)}this._next()}),t),this._tryToStartAnother(),this.emit("add")}))}async addAll(e,t){return Promise.all(e.map((async e=>this.add(e,t))))}start(){return this._isPaused?(this._isPaused=!1,this._processQueue(),this):this}pause(){this._isPaused=!0}clear(){this._queue=new this._queueClass}async onEmpty(){if(0!==this._queue.size)return new Promise((e=>{const t=this._resolveEmpty;this._resolveEmpty=()=>{t(),e()}}))}async onSizeLessThan(e){if(!(this._queue.size<e))return new Promise((t=>{const r=()=>{this._queue.size<e&&(this.removeListener("next",r),t())};this.on("next",r)}))}async onIdle(){if(0!==this._pendingCount||0!==this._queue.size)return new Promise((e=>{const t=this._resolveIdle;this._resolveIdle=()=>{t(),e()}}))}get size(){return this._queue.size}sizeBy(e){return this._queue.filter(e).length}get pending(){return this._pendingCount}get isPaused(){return this._isPaused}get timeout(){return this._timeout}set timeout(e){this._timeout=e}}const u=e.getLogger("@quotquot/element"),l=[NodeFilter.SHOW_ELEMENT,{acceptNode:e=>e.renderedBy?NodeFilter.FILTER_REJECT:NodeFilter.FILTER_ACCEPT}];class c extends HTMLElement{constructor({template:e,state:t={},Plugins:r=[],renderers:n=[]}){super(),this.attachShadow({mode:"open"}),this.state=t,this.renderers=n,this.plugins=r.map((e=>new e(this))),this.initializedPlugins=[],this.queue=new a({concurrency:1}),this.pending=[],e&&this.pending.push((()=>this.appendTemplate(e)))}onerror(e,t,...r){u.error(e,t,...r)}connectedCallback(){this.queue.addAll([()=>Promise.all(this.plugins.map((e=>e.setup&&e.setup(this).then((()=>this.initializedPlugins.push(e))).catch((t=>this.onerror(t,"plugin",e.name,"setup")))))).catch((e=>this.onerror(e,"connect"))),...this.pending.splice(0,this.pending.length)])}disconnectedCallback(){this.queue.add((()=>Promise.all(this.initializedPlugins.map((e=>e.cleanup&&e.cleanup(this).catch((t=>this.onerror(t,"plugin",e.name,"cleanup")))))).then((()=>{this.initializedPlugins.length=0})).catch((e=>this.onerror(e,"disconnect")))))}async appendTemplate(e){const t=e.content.cloneNode(!0);await this._renderSubtree(t,this.state,this.state),this.shadowRoot.appendChild(t)}$(e){return this.shadowRoot.querySelector(e)}$$(e){return this.shadowRoot.querySelectorAll(e)}async update(e){await this.queue.add((()=>this._update(e)))}async toggleState(e){await this.update({[e]:!this.state[e]})}async pushToState(e,t){const r=this.state[e];r.push(t),await this.update({[e]:r})}async _update(e){let t;await Promise.all(this.plugins.map((t=>t.onBeforeUpdate&&t.onBeforeUpdate(this,e).catch((e=>this.onerror(e,"before-update",t.name))))));try{if(e){const t=Object.assign({},this.state,e);await this._renderSubtree(this.shadowRoot,t,Object.keys(e)),this.state=t}else await this._renderSubtree(this.shadowRoot,this.state,this.state)}catch(e){t=e}await Promise.all(this.plugins.map((r=>r.onUpdated&&r.onUpdated(this,e,t).catch((e=>this.onerror(e,"updated",r.name))))))}async _renderSubtree(e,t,r,n,i){const s=Object.assign({},t,n),o=document.createTreeWalker(e,...l);for(;o.nextNode();){const e=[o.currentNode,this,s,r,n,i];await Promise.all(this.renderers.map((t=>t.renderElement&&t.renderElement(...e).catch((e=>this.onerror(e,"render-element",t.name))))))}}async _renderAttribute(e,t,r,n,i){const s=[e,this,Object.assign({},t,n),r,n,i];await Promise.all(this.renderers.map((e=>e.renderAttribute&&e.renderAttribute(...s).catch((t=>this.onerror(t,"render-attribute",e.name))))))}}export{c as default};
