# -*- coding: utf-8 -*-
from setuptools import setup

packages = \
['nuts', 'nuts.base_tests', 'nuts.helpers']

package_data = \
{'': ['*']}

install_requires = \
['PyYAML>=5.3.1,<6.0.0',
 'nornir-napalm>=0.1.1,<0.2.0',
 'nornir-netmiko>=0.1.1,<0.2.0',
 'nornir-utils>=0.1.0,<0.2.0',
 'nornir>=3.0.0,<4.0.0',
 'pytest>=6.1.1,<7.0.0']

entry_points = \
{'pytest11': ['nuts = nuts.plugin']}

setup_kwargs = {
    'name': 'nuts',
    'version': '3.1.0',
    'description': 'Network Unit Testing System Component of NetTowel',
    'long_description': '# NetTowel Network Unit Testing System\n\n## Introduction\n\nThe NetTowel Network Unit Testing System or "nuts" in short is the testing component of the NetTowel Project, which is developed at the Institute of Networked Solutions in Rapperswil, Switzerland.\nIt draws on the concept of unit tests, known from the domain of programming, and applies it to the domain of networking.\n\nOne major difference between unit tests in programming and \nnetwork tests is the definition of what a test actually is. \nIn programming, unit tests normally focus on testing edge cases, \nsince the amount of non-edge cases is not definable.\nIn the network testing domain, tests are less about edge cases, but more about testing existing network states with \npre-defined test cases. Such a single test case might be "can host A reach neighbors X, Y, Z?" on many different devices. \nThis is what nuts tries to achieve:\nApply test cases based on your pre-defined network topology to your actual network and have the tests confirm the correct state.\n\n## Installation Instructions\n\n### Using pip\n\nRun `pip install nuts` \n\n### Using poetry\n\nNuts uses [poetry](https://python-poetry.org/) as a dependency manager.\n\n1. [Install poetry](https://python-poetry.org/docs/#installation).\n2. Clone this repository.\n3. Run `$ poetry install`\n\n## How It Works: Test Bundles and Test Definitions\n\nThe project relies on the [pytest framework](https://docs.pytest.org/) to setup and execute the tests. \nNuts itself is written as a custom pytest plugin. In the background, [nornir](https://nornir.readthedocs.io/) \nexecutes specific network tasks for the actual tests.\n\nNuts treats the test definition and the so-called test bundle as separate entities. The *test definition* is modeled as a custom `pytest.Class`, and a predefined set of test definitions can be found in the nuts module `base_tests`. New test definitions can be added easily by the user of the plugin.\n\nThe *test bundle* is a file that is parsed by pytest. The file provides data on the desired network state and describes which test definitions should be collected and executed by pytest. \nThe structure of the test bundle should enable people without in-depth python knowledge to add new test bundles or update existing ones to reflect changes in the network. \n\nWhile the readme here is only a short overview, find the [documentation of nuts on readthedocs](https://nuts.readthedocs.io/en/latest/).\n\n### Test Bundle Structure\n\nCurrently only yaml files are supported as test bundles, \nbut other sources such as other file formats or database entries can be considered in later nuts versions.\n\nEach test bundle contains the following structure:\n```yaml\n---\n- test_module: <module that contains the test class> # optional\n  test_class: <name of the test class>\n  label: <label to uniquely identify the test> # optional \n  test_execution: <additional data used to execute the test> # optional\n  test_data: <data used to generate the test cases>\n...\n```\n`test_module`: The full path of the python module that contains the test class to be used.\nThis value is optional if the test class is registered in `index.py` of the pytest-nuts plugin.\nNote that it can be relevant in which directory `pytest` is started if local test modules are used. Using `test_modules` allows you to write your own test classes. **Note: We currently do not support self-written test modules, since upcoming refactorings might introduce breaking changes.**\n\n`test_class`: The name of the python class which contains the tests that should be executed.\nNote that currently every test in this class will be executed.\n\n`label`: Additional identifier that can be used to distinguish between multiple occurrences of the same \n test class in a test bundle.\n\n`test_execution`: Data that is exposed as part of the `nuts_parameters` property. \nBy convention this contains additional information that is passed directly to the nornir task in the background. \nTherefore the key-value pairs must be consistent with the key-value pairs of the specific nornir task. \nAs an example, the test definition `napalm_ping.py` calls a nornir task to execute napalm\'s ping-command. \nThis allows the additional `max_drop` parameter in `test_execution`, since it is in turn pre-defined by napalm.\n\n`test_data`: Data that is used to parametrize the tests in the test class which have the `pytest.mark.nuts` annotation. It is additionally part of the `nuts_parameters` property.\n\n### Example: CDP Neighbors\nExample of a test bundle for `TestNetmikoCdpNeighbors` which tests that `R1` is a CDP Neighbor of both `R2` and `R3`.\nThis example creates three different tests, one for each entry in the `test_data` list.\n\n```yaml\n---\n- test_module: nuts.base_tests.netmiko_cdp_neighbors\n  test_class: TestNetmikoCdpNeighbors\n  test_data:\n    - host: R1\n      local_port: GigabitEthernet3\n      destination_host: R2\n      management_ip: 172.16.12.2\n      remote_port: GigabitEthernet2\n    - host: R1\n      local_port: GigabitEthernet4\n      destination_host: R3\n      management_ip: 172.16.13.3\n      remote_port: GigabitEthernet2\n    - host: R2\n      local_port: GigabitEthernet2\n      destination_host: R1\n      management_ip: 172.16.12.1\n      remote_port: GigabitEthernet3\n...\n```\n\n### How the Test Bundle Is Converted to a Pytest Test\n\nWhen nuts is executed, pytest converts the test bundles (the yaml files) into tests. During test collection, the custom pytest marker `nuts` uses the data that has been defined in the test bundle mentioned above. \nThis annotation is a wrapper around the `pytest.mark.parametrize` annotation and allows the plugin to use the data entries from the test bundle. For each entry in the `test_data` section of the test bundle, the custom marker generates a single test case. To achieve this, the plugin transforms the entries into n-tuples, since `pytest.mark.parametrize` expects a list of n-tuples as input. \n\nThe custom nuts marker takes two arguments: The first argument of the annotation determines the required fields. \nFor each entry in `test_data` these fields are extracted and transformed to a tuple considering the correct order.\nIf any of these fields are not present in an entry of `test_data`, the corresponding test case will be skipped.\nA second argument determines optional fields that can also be used in a test case as well - non-present values are passed into the function as `None`.\n\nThe following test-run of CDP neighbors for example checks the local port:\n\n```python\nclass TestNetmikoCdpNeighbors:       \n    @pytest.mark.nuts("remote_host,local_port")\n    def test_local_port(self, single_result, remote_host, local_port):\n        assert single_result.result[remote_host]["local_port"] == local_port        \n```\n\n\nThe required fields are `host`, `remote_host` and `local_port` - they must be present in the custom marker, \nbut also be provided as argument to the test method itself.\n\n`single_result` uses the `host` field and provides the result that has been processed via the specific context of a test.\n\n### Test classes and their context\nEach test module implements a context class to provide module-specific functionality to its tests. This context class is a  `NutsContext` or a subclass of it. \nThis guarantees a consistent interface across all tests for test setup and execution. \nCurrently, the predefined test classes use [nornir](https://nornir.readthedocs.io/en/latest/) in order to communicate \nwith the network devices. Those test classes derive all from a more specific `NornirNutsContext`, \nwhich provides a nornir instance and nornir-specific helpers. In the example above, it is a class called `CdpNeighborsContext` that derives from `NornirNutsContext`.\n\nIf you want to learn more how nuts works but do not have a running network in the background, there\'s a nuts showcase - an offline test class that displays the basic functionality of nuts. See the [tutorial](https://nuts.readthedocs.io/en/latest/tutorial/firststeps.html) for further information.\n\n## Develop Your Own Test Classes\n\nNuts is essentially designed as a pytest-plugin and it is possible to add your own, self-written test classes. \nA dev documentation on how to write your own test classes is planned for a future release.\nStill, it is possible to write your own test classes nevertheless, even if we cannot guarantee that upcoming planned refactorings  do not introduce breaking changes.\n\n## Community-provided test classes\n\n* [Cisco IOSXE Test Class](https://github.com/briantsaunders/nuts-cisco-iosxe-tests) by [briantsaunders](https://github.com/briantsaunders)\n\n# Thanks\n\n* [Matthias Gabriel](https://github.com/MatthiasGabriel), who laid the foundations of nuts.\n* [Florian Bruhin (The Compiler)](https://github.com/The-Compiler) for invaluable feedback and advice.\n',
    'author': 'Lukas Murer, MÃ©line Sieber, Urs Baumann, Matthias Gabriel, Florian Bruhin',
    'author_email': None,
    'maintainer': 'Lukas Murer',
    'maintainer_email': 'lukas.murer@ost.ch',
    'url': 'https://github.com/INSRapperswil/Nuts',
    'packages': packages,
    'package_data': package_data,
    'install_requires': install_requires,
    'entry_points': entry_points,
    'python_requires': '>=3.7,<4.0',
}


setup(**setup_kwargs)
