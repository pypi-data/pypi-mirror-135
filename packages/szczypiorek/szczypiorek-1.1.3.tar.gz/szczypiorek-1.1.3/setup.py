# -*- coding: utf-8 -*-
from setuptools import setup

packages = \
['szczypiorek']

package_data = \
{'': ['*']}

install_requires = \
['PyYAML>=6.0,<7.0',
 'bash>=0.6,<0.7',
 'click>=8.0.3,<9.0.0',
 'python-gnupg>=0.4.8,<0.5.0',
 'validators>=0.18.2,<0.19.0']

entry_points = \
{'console_scripts': ['szczypiorek = szczypiorek.cli:cli']}

setup_kwargs = {
    'name': 'szczypiorek',
    'version': '1.1.3',
    'description': 'Szczypiorek environment management for humans.',
    'long_description': '<img src="./assets/szczypiorek_logo.png" height="300">\n\n# Szczypiorek - environment management for humans\n\n**szczypiorek** allows one:\n1. to define ones settings / credentials as a part of incredibly readable and flexible **yaml** format\n2. using as an extra **template variables** and **imports**\n3. and then define with minimal amount of code **environment parsers** which can be used to parse such yaml files\n4. and allow one to use them directly in their python code\n5. all of that on top of the mechanism allowing the secured storage and usage of most likely containing sensitive information yaml files.\n\n## Getting Started\n\nIn order to start one needs to perform below steps.\n\n### Creating yaml env file\n\nIt should contain some sort of settings, let\'s create one under `deploy/development.yml` folder:\n\n```yaml\naws:\n  secret: this is my secret\n  is_sensitive: true\n  age_days: 121\n```\n\n### Creating parser\n\nSomewhere in your code create a parser (e.g. `env.py`):\n\n```python\nimport szczypiorek as ev\n\n\nclass MyEnvParser(ev.EnvParser):\n\n    aws_secret = ev.CharField()\n\n    aws_is_sensitive = ev.BooleanField()\n\n    aws_age_days = ev.IntegerField()\n\n\nenv = MyEnvParser().parse()\n\n```\n\n### Protect data stored in yamls\n\nOne must make sure that the yaml file will be protected therefore run in the terminal:\n```bash\nszczypiorek encrypt ./deploy\n```\n\nMake sure to add to `.gitignore`\n```\n.szczypiorek_encryption_key\ndeploy/development.yml\n```\n\n### Replace secrets on the fly\n\nIn certain situations, like when one created dynamical resources during the deployment phase, one would like to be able to replace certain parts of existing `.szczyp` file with some dynamical values.\nIn order to achieve that one would have to use the `replace` command:\n\n\n```bash\nszczypiorek replace -r a.b:12 -r a.g.f.secret:password\n```\n\nBy default it would use the default encryption key and default szczyp file but one can overwrite it by passing extra arguments. Please run:\n\n```bash\nszczypiorek replace --help\n```\n\nTo learn more.\n\n## FAQ\n\n### How and in which order szczypiorek resolves encryption key and environment gpg?\n\n1. Encryption key is searched in various places in this order:\n- `SZCZYPIOREK_ENCRYPTION_KEY` environment variable where it\'s expected that the **content** of the **encryption key** will be stored.\n- `SZCZYPIOREK_ENCRYPTION_KEY_FILE` environment variable where the **path** to chosen **encryption key** file is stored\n- if above is not found szczypiorek tries default `.szczypiorek_encryption_key` file.\n\n2. Environment gpg is searched in various places in this order:\n- `SZCZYPIOREK_ENVIRONMENT_GPG` environment variable where it\'s expected that the **content** of the **environment gpg** will be stored.\n- `SZCZYPIOREK_ENVIRONMENT_GPG_FILE` environment variable where the **path** to chosen **environment gpg** file is stored\n- if above is not found szczypiorek tries default `env.gpg` file.\n\n### How szczypiorek behaves when deployed?\n\nWhen deployed for the parser to work correctly one needs two things:\n1. A single `env.gpg` file available in the root of the project\n2. A `.szczypiorek_encryption_key` storing the secret generated during the `encrypt` phase. WARNING! Make sure that this file is not kept in the repository itself but rather created dynamically during the deployment phase. Till that time it could be stored in for example `github secrets` or similar system such as `AWS secrets`, `Azure Key Vault` etc.\n\n### How szczypiorek behaves locally?\n\nFor the `szczypiorek` to work locally one needs 3 things:\n1. One `gpg` file for example `development.gpg`\n2. A environment variable `SZCZYPIOREK_ENVIRONMENT_GPG_FILE=development.gpg` pointing to that file\'s location\n3. A `.szczypiorek_encryption_key` file where a secret for decryption is stored.\n\n### One contributor changed gpg files would after PUSH & PULL sequence see the changes?\n\nTODO: add it\n\n### One contributor is changing the yaml files but the other cannot see those reflected in the gpg file?\n\nTODO: add it\n\n## The CLI - Available commands\n\nFIXME: add it!!!\n```bash\nszczypiorek print-env cosphere_api.conf.env.api_env\n```\n\n## The Environment Parser - Available fields\n\nTODO: add it\n\nUSE BELOW LEGACY AS INSPIRATION:\n\nUse the below example as a inspiration regarding type of fields one can define.\n\n```python\n\nimport szczypiorek as env\n\n\nclass MyEnvParser(env.EnvParser):\n\n    secret_key = env.CharField()\n\n    is_important = env.BooleanField()\n\n    aws_url = env.URLField()\n\n    number_of_workers = env.IntegerField()\n\n    unit_price = env.FloatField()\n\n```\n\nEach field supports the following arguments:\n\n- `required` (boolean) - if environment variable is required to be present\n- `default` (target type) - default to be used in case environment variable was not found\n- `allow_null` (boolean) - if environment variable can be nullable\n- `description` (str) - where one can describe the purpose of a given field when the name itself is not enough to capture it.\n\nBesides those some fields are supporting extra fields:\n\n- `CharField`:\n\n    - `min_length` - validates if minimum amount of characters was provided\n    - `max_length` - validates if maximum amount of characters was provided\n\n\n## The Environment YAML files - Reference\n\nTODO: add it\n    - decribe the usage of template variables\n\n## TODOS\n\nThere\'s still a lot of work to do, even though the basic functionality of **szczypiorek** is production ready:\n\n- [ ] **[HIGH PRIO]** enable versioning of secrets and a command which is able to clean up all unused secrets\n\n- [ ] **[HIGH PRIO]** use https://github.com/squidfunk/mkdocs-material for docs\n\n- [ ] **[HIGH PRIO]** host the docs on github pages https://www.mkdocs.org/user-guide/deploying-your-docs/\n\n- [ ] **[HIGH PRIO]** replace the parsing mechanism with Pydantic models to make it more modern and more like python static typing.\n\n- [ ] **[HIGH PRIO]** add an option to sync the secret of the admin\n\n- [ ] **[LOW PRIO]** Enable imports in the yml files. It should take the following form:\n```yaml\nimports:\n  - shared.yml\n  - development.yml\n```\nAnd then when running `encrypt` one stores at the level of gpg files all its dependencies therefore making it self contained. Before creating the gpg file it could create structure like:\n```yaml\n- filename: shared.yml\n  content: ...\n\n- filename: development.yml\n  content: ...\n\n# MAIN FILE\n- filename: integration.yml\n  content: ...\n```\nWhen running `decrypt` it "unpacks" all files with warnings that existing ones would be overwritten. There will be an option to force it without messages. When `decrypting` in the parser the imports are taken into account and therefore applied right away so the resulting `env` is just a result of applying all dependencies.\n\n- [ ] **[LOW PRIO]** support **DB_POSTGRES_CONNECT validator**:\n* it expects certain fields to be present\n* it allows fields mapping\n\n- [ ] **[LOW PRIO]** support **SENTRY_PING validator**:\n* it uses https://develop.sentry.dev/sdk/store/\n* it just pings the API\n\n- [ ] **[LOW PRIO]** support **OAUTH2_PING validator**:\n* it just creates a OAUTH2 session and tries not to fail while doing this\n\n- [ ] **[LOW PRIO]** support **API_PING validator**:\n* it just pings the API\n* it allows fields mapping\n\n- [ ] **[LOW PRIO]** support **AWS_S3_CLOUDFRONT_PING validator**:\n* it just pings the endpoint\n\n- [ ] **[LOW PRIO]** support **AWS_S3_BUCKET_LIST validator**:\n* it just lists the bucket\n\n- [ ] **[LOW PRIO]** support **AWS_POLLY_RENDER_SAMPLE validator**:\n* it renders simple text\n\n- [ ] **[LOW PRIO]** handle ROTATION of the **szczypiorek** secret itself. One can with one command run:\n* `decrypt`\n* render new key\n* `encrypt`\n\n- [ ] **[LOW PRIO]** support PRODUCTION gpg file where all validators etc are removed only the essential parts are left\n',
    'author': 'CoSphere Tech',
    'author_email': 'contact@cosphere.org',
    'maintainer': None,
    'maintainer_email': None,
    'url': 'https://github.com/cosphere-org/szczypiorek',
    'packages': packages,
    'package_data': package_data,
    'install_requires': install_requires,
    'entry_points': entry_points,
    'python_requires': '>=3.9.9,<3.10.0',
}


setup(**setup_kwargs)
