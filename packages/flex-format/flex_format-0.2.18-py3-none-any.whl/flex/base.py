# -*- coding: utf-8 -*-
from __future__ import annotations

import ast
import json
import warnings
from io import BytesIO, TextIOWrapper
from numbers import Number
from tarfile import TarFile, TarInfo
from typing import BinaryIO

import numpy as np

from .json_encoder import FlexJSONDecoder, FlexJSONEncoder

try:
    from astropy.io import fits
except ImportError:
    fits = None

FITS_DTYPES = (Number, np.bool_)


class FlexBase:
    """
    Abstract baseclass for both FlexFile and FlexExtensions
    bundles some required internal data functions
    """

    @classmethod
    def _prepare_json(cls, fname: str, data: dict) -> tuple[TarInfo, BinaryIO]:
        """Create json data for this object"""
        tio = TextIOWrapper(BytesIO(), "utf-8")
        json.dump(data, tio, cls=FlexJSONEncoder, allow_nan=False, skipkeys=False)
        bio = tio.detach()
        info = cls._get_tarinfo_from_bytesio(fname, bio)
        return info, bio

    @staticmethod
    def _parse_json(bio: BytesIO) -> dict:
        """Parse Json data to a dictionary using some datatype conversion"""
        data = json.load(bio, cls=FlexJSONDecoder)
        return data

    @classmethod
    def _read_json(cls, file: TarFile, name: str) -> dict:
        """Read object name from file"""
        bio = file.extractfile(name)
        data = cls._parse_json(bio)
        return data

    @staticmethod
    def _get_tarinfo_from_bytesio(fname, bio: BytesIO) -> TarInfo:
        """Create the TarInfo for arbirtary BytesIO"""
        info = TarInfo(fname)
        info.size = bio.tell()
        bio.seek(0)
        return info

    def _prepare_fits_header(self) -> fits.Header:
        """Convert header to FITS header, accounting for datatypes"""

        def floatstr(obj):
            if isinstance(obj, FITS_DTYPES):
                if obj != obj:  # obj is nan
                    return "nan"
                if np.isposinf(obj):
                    return "+inf"
                if np.isneginf(obj):
                    return "-inf"
                return obj
            if isinstance(obj, (str, np.str)):
                return ascii(obj)[1:-1]
            return ascii(repr(obj))[1:-1]

        def check_length(k, v):
            if (
                not isinstance(v, str)
                or not k.startswith("HIERARCH ")
                or len(k) + len(v) + 5 <= 80
            ):
                return v
            else:
                warnings.warn(
                    "The value of keyword %s is too long, it has been truncated"
                    "To avoid this reduce the length of the keyword to less than 8 characters"
                    % k
                )
                return ascii(v[: 80 - len(k) - 6])[1:-1]

        # FITS only allows strings and integers, so convert everything into str
        # But only in ASCII representation
        header = {k: floatstr(v) for k, v in self.header.items()}
        # The key must be 8 letters or less, otherwise use the HIERARCH extension
        # usually this is handled by the fits package, but here we need to check
        # the length of the key + value, see next point
        header = {k if len(k) <= 8 else "HIERARCH " + k: v for k, v in header.items()}
        # Also the length of the key + value is limited to 80 characters (including the delimiter '=')
        # If the key is not a HIERARCH extensions, we can use the CONTINUE extension to make it work
        # But HIERARCH and CONTINUE can not be combined so we truncate the value if it is a HIERARCH keyword
        header = {k: check_length(k, v) for k, v in header.items()}
        header = fits.Header(header)
        return header

    @classmethod
    def _parse_fits_header(cls, header: dict) -> dict:
        """Read a fits header accounting for datatypes"""
        INFINITY_VALUE = float("inf")
        NaN = float("NaN")

        def floatstr(obj):
            if obj == "nan":
                return NaN
            if obj == "inf":
                return INFINITY_VALUE
            if obj == "-inf":
                return -INFINITY_VALUE
            if isinstance(obj, str):
                if obj.startswith("array"):
                    return np.array(ast.literal_eval(obj[6:-1]))
                try:
                    return ast.literal_eval(obj)
                except Exception:
                    pass
            return obj

        header = {k: floatstr(v) for k, v in header.items()}
        return header


class FlexExtension(FlexBase):
    """
    Abstract baseclass for flex extensions
    each flex file can contain any number of flex extensions

    Each extensions specifies the module and class it was generated by
    in its header using the __module__ and __class__ keywords
    """

    def __init__(self, header: dict = None, cls=None, **kwargs):
        # dict: Extension header
        self.header: dict = header if header is not None else {}
        if cls is not None:
            try:
                self.header["__module__"] = cls.__module__
                self.header["__class__"] = cls.__name__
            except AttributeError:
                mod, cls = cls.rsplit(".", 1)
                self.header["__module__"] = mod
                self.header["__class__"] = cls
        else:
            self.header["__module__"] = self.__class__.__module__
            self.header["__class__"] = self.__class__.__name__
        self.header["__header__"] = True

    def _prepare(self, name: str) -> tuple[tuple[TarInfo, BinaryIO]]:
        """Prepare the extension for saving"""
        raise NotImplementedError

    @classmethod
    def _parse(cls, header: dict, members: dict) -> FlexExtension:
        """read this extension from disk"""
        raise NotImplementedError

    def to_dict(self) -> dict:
        """convert the extension to a dictionary"""
        raise NotImplementedError

    @classmethod
    def from_dict(cls, header: dict, data: dict) -> FlexExtension:
        """read this extension from a dictionary"""
        raise NotImplementedError
