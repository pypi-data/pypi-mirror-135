# AUTOGENERATED! DO NOT EDIT! File to edit: nbs/11_simulate.ipynb (unless otherwise specified).

__all__ = ['gen_white', 'gen_uni', 'create_EEG', 'amp_spectrum', 'generate_pink_noise', 'create_ongoing_stationary',
           'create_ongoing']

# Cell
import numpy as np
from scipy.fft import fft, ifft
import pandas as pd
import mne
from .core import *
import matplotlib.pyplot as plt

# Cell
def gen_white(amp, n_channels, points, trials):
    return amp * np.random.randn(n_channels, points, trials)

# Cell
def gen_uni(amp, n_channels, points, trials):
    return amp * np.random.rand(n_channels, points, trials) + 0.5  # remove DC

# Cell
def create_EEG(sfreq=500, trials=30, n_channels=8):
    points = sfreq * 2
    times = np.arange(0, points)/sfreq

    EEG = {
    'srate': sfreq,
    'pnts': points,
    'trials': trials,
    'nbchan': n_channels,
    'times': times,
    'data':  gen_white(1, n_channels, points, trials)
}
    return EEG

# Cell
def amp_spectrum(EEG, ed=50):
    # generate one-sided 1/f amplitude spectrum
    freqs = np.random.rand(1, EEG['pnts']) # uniform dist
    points = np.arange(0, EEG['pnts'])
    return  freqs * np.exp(-points/ed)

# Cell
def generate_pink_noise(EEG, ed=1):
    n_channels, points, trials = EEG['nbchan'], EEG['pnts'], EEG['trials']
    EEG['data'] = np.zeros((n_channels, points, trials))
    for ch in range(n_channels):
        for t in range(trials):
            amps = amp_spectrum(EEG, ed)
            phases = np.exp(1j*2*np.pi*np.random.rand(*amps.shape)) # random phases
            # Fourier coefficients as amplitudes times random phases
            fc = amps * phases
            # inverse fourier transform to create the noise
            EEG['data'][ch, :, t] = np.real(ifft(fc))
    return EEG

# Cell
def create_ongoing_stationary(EEG, freqs, amps, plock=True):
    for ch in range(EEG["nbchan"]):
        for t in range(EEG["trials"]):
            # create multicomponent sine wave
            sinewave = np.zeros((1, EEG["pnts"]))
            for idx, _ in enumerate(freqs):
                # phase-lock sinewaves
                if plock:
                    sinewave = sinewave + amps[idx] * np.sin(2 * np.pi * EEG["times"] * freqs[idx])
                else:
                    sinewave = sinewave + amps[idx] * np.sin(2 * np.pi * EEG["times"] * freqs[idx] + np.random.randn() * 2 * np.pi)

            # data as a sine wave + noise
            EEG["data"][ch, :, t] = sinewave * np.random.randn(len(sinewave))
    return EEG

# Cell
def create_ongoing(EEG, peak_freq=14, fwhm=5):
    hz = np.linspace(0, EEG['srate'], EEG['pnts']) # frequencies
    s = fwhm*(2*np.pi-1)/(4*np.pi) # normalized width
    x = hz-peak_freq # shifted frequencies
    fg = np.exp(-.5*(x/s)**2) # frequency-domain gaussian

    for ch in range(EEG['nbchan']):
        for t in range(EEG['trials']):
            # fourier coefficients of random spectrum
            fc = np.random.rand(1, EEG['pnts']) * np.exp(1j*2*np.pi*np.random.rand(1, EEG['pnts']))
            # taper Fourier coefficients by the Gaussian
            fc = fc * fg
            # return to time-domain to get EEG data
            EEG['data'][ch, :, t] = np.real(ifft(fc))
    return EEG, fc