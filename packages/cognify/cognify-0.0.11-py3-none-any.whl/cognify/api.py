# AUTOGENERATED! DO NOT EDIT! File to edit: nbs/10_api.ipynb (unless otherwise specified).

__all__ = ['API', 'login', 'query_eeg_ids', 'query_eeg', 'eeg_query', 'run_query', 'parse_eeg_query', 'query_eeg_opt']

# Cell
import asyncio
import time

import numpy as np
import pandas as pd
from gql import Client, gql
from gql.transport.aiohttp import AIOHTTPTransport

from cognify import dataset

# Cell
class API:
    url = "https://dev.insaicognition.com/graphql"
    token, org, transport, client = None, None, None, None
    org = None
    execute_timeout = 10_000

    def __init__(self, url=None):
        if url:
            self.url = url
        self.transport = AIOHTTPTransport(url=self.url)
        self.client = Client(
            transport=self.transport,
            fetch_schema_from_transport=True,
            execute_timeout=self.execute_timeout,
        )

# Cell
async def login(self, email: str, password: str):
    mutation = gql(
        """
        mutation login($email: String!, $password: String!) {
          login(email: $email, password: $password) {
            accessToken
            user {
              id
              email
              name
              organization {
                id
              }
            }
          }
        }
    """
    )
    params = {"email": email, "password": password}
    result = await self.client.execute_async(mutation, variable_values=params)
    self.token = result["login"]["accessToken"]
    self.org = result["login"]["user"]["organization"][0]["id"]
    self.transport = AIOHTTPTransport(url=self.url, headers={"authorization": self.token, "organization": self.org})
    self.client = Client(
        transport=self.transport,
        fetch_schema_from_transport=True,
        execute_timeout=self.execute_timeout,
    )

# Cell
API.login = login

# Cell
async def query_eeg_ids(self, metric_id: str):
    query = gql(
        """
        query biometric($metricId: String!) {
          eegs(where: {metricId: {equals: $metricId}}) {
            id
          }
        }
    """
    )
    params = {"metricId": metric_id}
    result = await self.client.execute_async(query, variable_values=params)
    return result["eegs"]

# Cell
API.query_eeg_ids = query_eeg_ids

# Cell
async def query_eeg(self, metric_id: str, take: int = None, skip: int = None):
    t0 = time.time()
    query = gql(
        """
        query eeg($metricId: String!, $take: Int, $skip: Int) {
          eegs(where: {metricId: {equals: $metricId}},
            take: $take, skip: $skip, orderBy: {startTime: asc}) {
            startTime
            samplingRate
            samples {
              id
              channel
              data
            }
          }
        }
    """
    )
    params = {"metricId": metric_id, "take": take, "skip": skip}
    result = await self.client.execute_async(query, variable_values=params)
    print(f"{time.time()-t0:.2f} sec.")
    return result["eegs"]

# Cell
API.query_eeg = query_eeg

# Cell
def eeg_query():
    return gql(
        """
        query eeg($metricId: String!, $take: Int, $skip: Int) {
          eegs(where: {metricId: {equals: $metricId}},
            take: $take, skip: $skip, orderBy: {startTime: asc}) {
            startTime
            samplingRate
            samples {
              id
              channel
              data
            }
          }
        }
    """
    )

# Cell
async def run_query(query, session, params):
    return await session.execute(query, variable_values=params)

# Cell
def parse_eeg_query(query_res):
    df = pd.DataFrame(query_res["eegs"]).rename(columns={"startTime": "start_time", "samplingRate": "sampling_rate"})
    samples = df.explode("samples")["samples"].apply(pd.Series)  # parse nested samples
    return df.drop(columns="samples").join(samples).sort_values(by=["start_time", "channel"])

# Cell
async def query_eeg_opt(self, metric_id: str, n_items: int = 200, parse: bool = True):
    t0 = time.time()
    # fetch number of epochs and calculate number round trips
    epoch_ids = await self.query_eeg_ids(metric_id)
    round_trips = math.ceil(len(epoch_ids) / n_items)
    # split into sub queries and fetch in parallel
    async with self.client as session:
        tasks = [
            asyncio.create_task(
                run_query(
                    eeg_query(),
                    session,
                    {"metricId": metric_id, "take": n_items, "skip": n_items * i},
                )
            )
            for i in range(round_trips)
        ]
        data = await asyncio.gather(*tasks)
    print(f"DURATION: {time.time()-t0:.2f} sec.")
    if parse:
        # TODO: quite slow, should be optimized
        return pd.concat([parse_eeg_query(d) for d in data]).sort_values(by=["start_time", "channel"])
    else:
        return data

# Cell
API.query_eeg_opt = query_eeg_opt