{"version":3,"file":"vendors-node_modules_three-trackballcontrols-ts_dist_index_js.5e1d99363266eb24001b.js","mappings":";;;;;;;;;;;;;;AAA+B;AAC/B,gBAAgB;AAChB,uBAAuB;AACvB,sBAAsB;AACtB,oBAAoB;AACpB;AACA,0BAA0B,0CAAa;AACvC,oBAAoB;AACb,gCAAgC,kDAAqB;AAC5D;AACA;AACA;AACA,+BAA+B,0CAAa;AAC5C;AACA;AACA;AACA,+BAA+B,0CAAa;AAC5C;AACA;AACA;AACA,6BAA6B,0CAAa;AAC1C,mCAAmC,6CAAgB;AACnD,qCAAqC,0CAAa;AAClD,0CAA0C,0CAAa;AACvD,gDAAgD,0CAAa;AAC7D,sCAAsC,0CAAa;AACnD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,oCAAoC,0CAAa;AACjD,iCAAiC,0CAAa;AAC9C,4BAA4B,0CAAa;AACzC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,wBAAwB;AACxB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,8BAA8B,MAAM,+CAAkB,UAAU,8CAAiB,SAAS,4CAAe;AACzG;AACA,0BAA0B,0CAAa;AACvC;AACA;AACA,wBAAwB,0CAAa;AACrC,6BAA6B,0CAAa;AAC1C,6BAA6B,0CAAa;AAC1C,6BAA6B,0CAAa;AAC1C;AACA,8BAA8B,0CAAa;AAC3C,4BAA4B,0CAAa;AACzC;AACA;AACA,6BAA6B,0CAAa;AAC1C,2BAA2B,0CAAa;AACxC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA","sources":["webpack://klampt-jupyter-widget/./node_modules/three-trackballcontrols-ts/dist/index.js"],"sourcesContent":["import * as THREE from 'three';\nconst STATE = { NONE: -1, ROTATE: 0, ZOOM: 1, PAN: 2, TOUCH_ROTATE: 3, TOUCH_ZOOM_PAN: 4 };\nconst CHANGE_EVENT = { type: 'change' };\nconst START_EVENT = { type: 'start' };\nconst END_EVENT = { type: 'end' };\nconst EPS = 0.000001;\nconst LAST_POSITION = new THREE.Vector3();\nconst LAST_ZOOM = { value: 1 };\nexport class TrackballControls extends THREE.EventDispatcher {\n    constructor(camera, domElement, domWindow) {\n        super();\n        this.getMouseOnScreen = (pageX, pageY) => {\n            const vector = new THREE.Vector2();\n            return vector.set((pageX - this.screen.left) / this.screen.width, (pageY - this.screen.top) / this.screen.height);\n        };\n        this.getMouseOnCircle = (pageX, pageY) => {\n            const vector = new THREE.Vector2();\n            return vector.set((pageX - this.screen.width * 0.5 - this.screen.left) / (this.screen.width * 0.5), (this.screen.height + 2 * (this.screen.top - pageY)) / this.screen.width);\n        };\n        this.rotateCamera = () => {\n            const axis = new THREE.Vector3();\n            const quaternion = new THREE.Quaternion();\n            const eyeDirection = new THREE.Vector3();\n            const cameraUpDirection = new THREE.Vector3();\n            const cameraSidewaysDirection = new THREE.Vector3();\n            const moveDirection = new THREE.Vector3();\n            let angle;\n            moveDirection.set(this._moveCurr.x - this._movePrev.x, this._moveCurr.y - this._movePrev.y, 0);\n            angle = moveDirection.length();\n            if (angle) {\n                this._eye.copy(this.camera.position).sub(this.target);\n                eyeDirection.copy(this._eye).normalize();\n                cameraUpDirection.copy(this.camera.up).normalize();\n                cameraSidewaysDirection.crossVectors(cameraUpDirection, eyeDirection).normalize();\n                cameraUpDirection.setLength(this._moveCurr.y - this._movePrev.y);\n                cameraSidewaysDirection.setLength(this._moveCurr.x - this._movePrev.x);\n                moveDirection.copy(cameraUpDirection.add(cameraSidewaysDirection));\n                axis.crossVectors(moveDirection, this._eye).normalize();\n                angle *= this.rotateSpeed;\n                quaternion.setFromAxisAngle(axis, angle);\n                this._eye.applyQuaternion(quaternion);\n                this.camera.up.applyQuaternion(quaternion);\n                this._lastAxis.copy(axis);\n                this._lastAngle = angle;\n            }\n            else if (!this.staticMoving && this._lastAngle) {\n                this._lastAngle *= Math.sqrt(1.0 - this.dynamicDampingFactor);\n                this._eye.copy(this.camera.position).sub(this.target);\n                quaternion.setFromAxisAngle(this._lastAxis, this._lastAngle);\n                this._eye.applyQuaternion(quaternion);\n                this.camera.up.applyQuaternion(quaternion);\n            }\n            this._movePrev.copy(this._moveCurr);\n        };\n        this.zoomCamera = () => {\n            let factor = 0;\n            if (this._state === STATE.TOUCH_ZOOM_PAN) {\n                factor = this._touchZoomDistanceStart / this._touchZoomDistanceEnd;\n                this._touchZoomDistanceStart = this._touchZoomDistanceEnd;\n                if (this.camera['isPerspectiveCamera']) {\n                    this._eye.multiplyScalar(factor);\n                }\n                else if (this.camera['isOrthographicCamera']) {\n                    this.camera.zoom *= factor;\n                    this.camera.updateProjectionMatrix();\n                }\n                else {\n                    console.warn('THREE.TrackballControls: Unsupported camera type');\n                }\n            }\n            else {\n                factor = 1.0 + (this._zoomEnd.y - this._zoomStart.y) * this.zoomSpeed;\n                if (factor !== 1.0 && factor > 0.0) {\n                    if (this.camera['isPerspectiveCamera']) {\n                        this._eye.multiplyScalar(factor);\n                    }\n                    else if (this.camera['isOrthographicCamera']) {\n                        this.camera.zoom /= factor;\n                        this.camera.updateProjectionMatrix();\n                    }\n                    else {\n                        console.warn('THREE.TrackballControls: Unsupported camera type');\n                    }\n                }\n                if (this.staticMoving) {\n                    this._zoomStart.copy(this._zoomEnd);\n                }\n                else {\n                    this._zoomStart.y += (this._zoomEnd.y - this._zoomStart.y) * this.dynamicDampingFactor;\n                }\n            }\n        };\n        this.panCamera = () => {\n            const mouseChange = new THREE.Vector2();\n            const cameraUp = new THREE.Vector3();\n            const pan = new THREE.Vector3();\n            mouseChange.copy(this._panEnd).sub(this._panStart);\n            if (mouseChange.lengthSq()) {\n                if (this.camera['isOrthographicCamera']) {\n                    const scale_x = (this.camera.right - this.camera.left) /\n                        this.camera.zoom /\n                        this.domElement.clientWidth;\n                    const scale_y = (this.camera.top - this.camera.bottom) /\n                        this.camera.zoom /\n                        this.domElement.clientWidth;\n                    mouseChange.x *= scale_x;\n                    mouseChange.y *= scale_y;\n                }\n                mouseChange.multiplyScalar(this._eye.length() * this.panSpeed);\n                pan.copy(this._eye).cross(this.camera.up).setLength(mouseChange.x);\n                pan.add(cameraUp.copy(this.camera.up).setLength(mouseChange.y));\n                this.camera.position.add(pan);\n                this.target.add(pan);\n                if (this.staticMoving) {\n                    this._panStart.copy(this._panEnd);\n                }\n                else {\n                    this._panStart.add(mouseChange.subVectors(this._panEnd, this._panStart).multiplyScalar(this.dynamicDampingFactor));\n                }\n            }\n        };\n        if (domElement === undefined)\n            console.warn('THREE.TrackballControls: The second parameter \"domElement\" is now mandatory.');\n        this.camera = camera;\n        this.domElement = domElement;\n        this.window = domWindow !== undefined ? domWindow : window;\n        // Set to false to disable this control\n        this.enabled = true;\n        this.screen = { left: 0, top: 0, width: 0, height: 0 };\n        this.rotateSpeed = 1.0;\n        this.zoomSpeed = 1.2;\n        this.panSpeed = 0.3;\n        this.noRotate = false;\n        this.noZoom = false;\n        this.noPan = false;\n        this.staticMoving = false;\n        this.dynamicDampingFactor = 0.2;\n        // How far you can dolly in and out ( PerspectiveCamera only )\n        this.minDistance = 0;\n        this.maxDistance = Infinity;\n        this.keys = [65 /*A*/, 83 /*S*/, 68 /*D*/];\n        // Replace ZOOM by DOLLY (threejs r111)\n        this.mouseButtons = { LEFT: THREE.MOUSE.ROTATE, MIDDLE: THREE.MOUSE.DOLLY, RIGHT: THREE.MOUSE.PAN };\n        // \"target\" sets the location of focus, where the camera orbits around\n        this.target = new THREE.Vector3();\n        this._state = STATE.NONE;\n        this._keyState = STATE.NONE;\n        this._eye = new THREE.Vector3();\n        this._movePrev = new THREE.Vector2();\n        this._moveCurr = new THREE.Vector2();\n        this._lastAxis = new THREE.Vector3();\n        this._lastAngle = 0;\n        this._zoomStart = new THREE.Vector2();\n        this._zoomEnd = new THREE.Vector2();\n        this._touchZoomDistanceStart = 0;\n        this._touchZoomDistanceEnd = 0;\n        this._panStart = new THREE.Vector2();\n        this._panEnd = new THREE.Vector2();\n        this.target0 = this.target.clone();\n        this.position0 = this.camera.position.clone();\n        this.up0 = this.camera.up.clone();\n        this.zoom0 = this.camera.zoom;\n        // event handlers - FSM: listen for events and reset state\n        this.keydown = (event) => {\n            if (this.enabled === false)\n                return;\n            this.window.removeEventListener('keydown', this.keydown);\n            if (this._keyState !== STATE.NONE) {\n                return;\n            }\n            else if (event.keyCode === this.keys[STATE.ROTATE] && !this.noRotate) {\n                this._keyState = STATE.ROTATE;\n            }\n            else if (event.keyCode === this.keys[STATE.ZOOM] && !this.noZoom) {\n                this._keyState = STATE.ZOOM;\n            }\n            else if (event.keyCode === this.keys[STATE.PAN] && !this.noPan) {\n                this._keyState = STATE.PAN;\n            }\n        };\n        this.keyup = () => {\n            if (this.enabled === false) {\n                return;\n            }\n            this._keyState = STATE.NONE;\n            this.window.addEventListener('keydown', this.keydown, false);\n        };\n        this.mousedown = (event) => {\n            if (this.enabled === false) {\n                return;\n            }\n            event.preventDefault();\n            event.stopPropagation();\n            if (this._state === STATE.NONE) {\n                switch (event.button) {\n                    case this.mouseButtons.LEFT:\n                        this._state = STATE.ROTATE;\n                        break;\n                    case this.mouseButtons.MIDDLE:\n                        this._state = STATE.ZOOM;\n                        break;\n                    case this.mouseButtons.RIGHT:\n                        this._state = STATE.PAN;\n                        break;\n                    default:\n                        this._state = STATE.NONE;\n                }\n            }\n            const state = this._keyState !== STATE.NONE ? this._keyState : this._state;\n            if (state === STATE.ROTATE && !this.noRotate) {\n                this._moveCurr.copy(this.getMouseOnCircle(event.pageX, event.pageY));\n                this._movePrev.copy(this._moveCurr);\n            }\n            else if (state === STATE.ZOOM && !this.noZoom) {\n                this._zoomStart.copy(this.getMouseOnScreen(event.pageX, event.pageY));\n                this._zoomEnd.copy(this._zoomStart);\n            }\n            else if (state === STATE.PAN && !this.noPan) {\n                this._panStart.copy(this.getMouseOnScreen(event.pageX, event.pageY));\n                this._panEnd.copy(this._panStart);\n            }\n            document.addEventListener('mousemove', this.mousemove, false);\n            document.addEventListener('mouseup', this.mouseup, false);\n            this.dispatchEvent(START_EVENT);\n        };\n        this.mousemove = (event) => {\n            if (this.enabled === false) {\n                return;\n            }\n            event.preventDefault();\n            event.stopPropagation();\n            const state = this._keyState !== STATE.NONE ? this._keyState : this._state;\n            if (state === STATE.ROTATE && !this.noRotate) {\n                this._movePrev.copy(this._moveCurr);\n                this._moveCurr.copy(this.getMouseOnCircle(event.pageX, event.pageY));\n            }\n            else if (state === STATE.ZOOM && !this.noZoom) {\n                this._zoomEnd.copy(this.getMouseOnScreen(event.pageX, event.pageY));\n            }\n            else if (state === STATE.PAN && !this.noPan) {\n                this._panEnd.copy(this.getMouseOnScreen(event.pageX, event.pageY));\n            }\n        };\n        this.mouseup = (event) => {\n            if (this.enabled === false) {\n                return;\n            }\n            event.preventDefault();\n            event.stopPropagation();\n            this._state = STATE.NONE;\n            document.removeEventListener('mousemove', this.mousemove);\n            document.removeEventListener('mouseup', this.mouseup);\n            this.dispatchEvent(END_EVENT);\n        };\n        this.mousewheel = (event) => {\n            if (this.enabled === false) {\n                return;\n            }\n            if (this.noZoom === true)\n                return;\n            event.preventDefault();\n            event.stopPropagation();\n            switch (event.deltaMode) {\n                case 2:\n                    // Zoom in pages\n                    this._zoomStart.y -= event.deltaY * 0.025;\n                    break;\n                case 1:\n                    // Zoom in lines\n                    this._zoomStart.y -= event.deltaY * 0.01;\n                    break;\n                default:\n                    // undefined, 0, assume pixels\n                    this._zoomStart.y -= event.deltaY * 0.00025;\n                    break;\n            }\n            this.dispatchEvent(START_EVENT);\n            this.dispatchEvent(END_EVENT);\n        };\n        this.touchstart = (event) => {\n            if (this.enabled === false) {\n                return;\n            }\n            event.preventDefault();\n            switch (event.touches.length) {\n                case 1:\n                    this._state = STATE.TOUCH_ROTATE;\n                    this._moveCurr.copy(this.getMouseOnCircle(event.touches[0].pageX, event.touches[0].pageY));\n                    this._movePrev.copy(this._moveCurr);\n                    break;\n                default:\n                    // 2 or more\n                    this._state = STATE.TOUCH_ZOOM_PAN;\n                    const dx = event.touches[0].pageX - event.touches[1].pageX;\n                    const dy = event.touches[0].pageY - event.touches[1].pageY;\n                    this._touchZoomDistanceEnd = this._touchZoomDistanceStart = Math.sqrt(dx * dx + dy * dy);\n                    const x = (event.touches[0].pageX + event.touches[1].pageX) / 2;\n                    const y = (event.touches[0].pageY + event.touches[1].pageY) / 2;\n                    this._panStart.copy(this.getMouseOnScreen(x, y));\n                    this._panEnd.copy(this._panStart);\n                    break;\n            }\n            this.dispatchEvent(START_EVENT);\n        };\n        this.touchmove = (event) => {\n            if (this.enabled === false) {\n                return;\n            }\n            event.preventDefault();\n            event.stopPropagation();\n            switch (event.touches.length) {\n                case 1:\n                    this._movePrev.copy(this._moveCurr);\n                    this._moveCurr.copy(this.getMouseOnCircle(event.touches[0].pageX, event.touches[0].pageY));\n                    break;\n                default:\n                    // 2 or more\n                    const dx = event.touches[0].pageX - event.touches[1].pageX;\n                    const dy = event.touches[0].pageY - event.touches[1].pageY;\n                    this._touchZoomDistanceEnd = Math.sqrt(dx * dx + dy * dy);\n                    const x = (event.touches[0].pageX + event.touches[1].pageX) / 2;\n                    const y = (event.touches[0].pageY + event.touches[1].pageY) / 2;\n                    this._panEnd.copy(this.getMouseOnScreen(x, y));\n                    break;\n            }\n        };\n        this.touchend = (event) => {\n            if (this.enabled === false) {\n                return;\n            }\n            switch (event.touches.length) {\n                case 0:\n                    this._state = STATE.NONE;\n                    break;\n                case 1:\n                    this._state = STATE.TOUCH_ROTATE;\n                    this._moveCurr.copy(this.getMouseOnCircle(event.touches[0].pageX, event.touches[0].pageY));\n                    this._movePrev.copy(this._moveCurr);\n                    break;\n            }\n            this.dispatchEvent(END_EVENT);\n        };\n        this.contextmenu = (event) => {\n            if (this.enabled === false) {\n                return;\n            }\n            event.preventDefault();\n        };\n        this.domElement.addEventListener('contextmenu', this.contextmenu, false);\n        this.domElement.addEventListener('mousedown', this.mousedown, false);\n        this.domElement.addEventListener('wheel', this.mousewheel, false);\n        this.domElement.addEventListener('touchstart', this.touchstart, false);\n        this.domElement.addEventListener('touchend', this.touchend, false);\n        this.domElement.addEventListener('touchmove', this.touchmove, false);\n        this.window.addEventListener('keydown', this.keydown, false);\n        this.window.addEventListener('keyup', this.keyup, false);\n        this.handleResize();\n        // force an update at start\n        this.update();\n    }\n    dispose() {\n        this.domElement.removeEventListener('contextmenu', this.contextmenu, false);\n        this.domElement.removeEventListener('mousedown', this.mousedown, false);\n        this.domElement.removeEventListener('wheel', this.mousewheel, false);\n        this.domElement.removeEventListener('touchstart', this.touchstart, false);\n        this.domElement.removeEventListener('touchend', this.touchend, false);\n        this.domElement.removeEventListener('touchmove', this.touchmove, false);\n        document.removeEventListener('mousemove', this.mousemove, false);\n        document.removeEventListener('mouseup', this.mouseup, false);\n        this.window.removeEventListener('keydown', this.keydown, false);\n        this.window.removeEventListener('keyup', this.keyup, false);\n    }\n    // ------------------------------------------------\n    handleResize() {\n        const box = this.domElement.getBoundingClientRect();\n        // adjustments come from similar code in the jquery offset() function\n        const d = this.domElement.ownerDocument.documentElement;\n        this.screen.left = box.left + this.window.pageXOffset - d.clientLeft;\n        this.screen.top = box.top + this.window.pageYOffset - d.clientTop;\n        this.screen.width = box.width;\n        this.screen.height = box.height;\n    }\n    checkDistances() {\n        if (!this.noZoom || !this.noPan) {\n            if (this._eye.lengthSq() > this.maxDistance * this.maxDistance) {\n                this.camera.position.addVectors(this.target, this._eye.setLength(this.maxDistance));\n                this._zoomStart.copy(this._zoomEnd);\n            }\n            if (this._eye.lengthSq() < this.minDistance * this.minDistance) {\n                this.camera.position.addVectors(this.target, this._eye.setLength(this.minDistance));\n                this._zoomStart.copy(this._zoomEnd);\n            }\n        }\n    }\n    update() {\n        this._eye.subVectors(this.camera.position, this.target);\n        if (!this.noRotate) {\n            this.rotateCamera();\n        }\n        if (!this.noZoom) {\n            this.zoomCamera();\n        }\n        if (!this.noPan) {\n            this.panCamera();\n        }\n        this.camera.position.addVectors(this.target, this._eye);\n        if (this.camera['isPerspectiveCamera']) {\n            this.checkDistances();\n            this.camera.lookAt(this.target);\n            if (LAST_POSITION.distanceToSquared(this.camera.position) > EPS) {\n                this.dispatchEvent(CHANGE_EVENT);\n                LAST_POSITION.copy(this.camera.position);\n            }\n        }\n        else if (this.camera['isOrthographicCamera']) {\n            this.camera.lookAt(this.target);\n            if (LAST_POSITION.distanceToSquared(this.camera.position) > EPS || LAST_ZOOM.value !== this.camera.zoom) {\n                this.dispatchEvent(CHANGE_EVENT);\n                LAST_POSITION.copy(this.camera.position);\n                LAST_ZOOM.value = this.camera.zoom;\n            }\n            else {\n                console.warn('THREE.TrackballControls: Unsupported camera type');\n            }\n        }\n    }\n    reset() {\n        this._state = STATE.NONE;\n        this._keyState = STATE.NONE;\n        this.target.copy(this.target0);\n        this.camera.position.copy(this.position0);\n        this.camera.up.copy(this.up0);\n        this.camera.zoom = this.zoom0;\n        this._eye.subVectors(this.camera.position, this.target);\n        this.camera.lookAt(this.target);\n        this.dispatchEvent(CHANGE_EVENT);\n        LAST_POSITION.copy(this.camera.position);\n        LAST_ZOOM.value = this.camera.zoom;\n    }\n}\n"],"names":[],"sourceRoot":""}