# -*- coding: utf-8 -*-
from setuptools import setup

packages = \
['lingua']

package_data = \
{'': ['*'],
 'lingua': ['language-models/af/*',
            'language-models/ar/*',
            'language-models/az/*',
            'language-models/be/*',
            'language-models/bg/*',
            'language-models/bn/*',
            'language-models/bs/*',
            'language-models/ca/*',
            'language-models/cs/*',
            'language-models/cy/*',
            'language-models/da/*',
            'language-models/de/*',
            'language-models/el/*',
            'language-models/en/*',
            'language-models/eo/*',
            'language-models/es/*',
            'language-models/et/*',
            'language-models/eu/*',
            'language-models/fa/*',
            'language-models/fi/*',
            'language-models/fr/*',
            'language-models/ga/*',
            'language-models/gu/*',
            'language-models/he/*',
            'language-models/hi/*',
            'language-models/hr/*',
            'language-models/hu/*',
            'language-models/hy/*',
            'language-models/id/*',
            'language-models/is/*',
            'language-models/it/*',
            'language-models/ja/*',
            'language-models/ka/*',
            'language-models/kk/*',
            'language-models/ko/*',
            'language-models/la/*',
            'language-models/lg/*',
            'language-models/lt/*',
            'language-models/lv/*',
            'language-models/mi/*',
            'language-models/mk/*',
            'language-models/mn/*',
            'language-models/mr/*',
            'language-models/ms/*',
            'language-models/nb/*',
            'language-models/nl/*',
            'language-models/nn/*',
            'language-models/pa/*',
            'language-models/pl/*',
            'language-models/pt/*',
            'language-models/ro/*',
            'language-models/ru/*',
            'language-models/sk/*',
            'language-models/sl/*',
            'language-models/sn/*',
            'language-models/so/*',
            'language-models/sq/*',
            'language-models/sr/*',
            'language-models/st/*',
            'language-models/sv/*',
            'language-models/sw/*',
            'language-models/ta/*',
            'language-models/te/*',
            'language-models/th/*',
            'language-models/tl/*',
            'language-models/tn/*',
            'language-models/tr/*',
            'language-models/ts/*',
            'language-models/uk/*',
            'language-models/ur/*',
            'language-models/vi/*',
            'language-models/xh/*',
            'language-models/yo/*',
            'language-models/zh/*',
            'language-models/zu/*']}

install_requires = \
['regex>=2021.11,<2023.0']

setup_kwargs = {
    'name': 'lingua-language-detector',
    'version': '1.0.1',
    'description': 'An accurate natural language detection library, suitable for long and short text alike',
    'long_description': '<img src="https://raw.githubusercontent.com/pemistahl/lingua-py/main/images/logo.png" alt="Lingua Logo" />\n\n<br>\n\n[![build](https://github.com/pemistahl/lingua-py/actions/workflows/build.yml/badge.svg?branch=main)](https://github.com/pemistahl/lingua-py/actions/workflows/build.yml)\n[![codecov](https://codecov.io/gh/pemistahl/lingua-py/branch/main/graph/badge.svg)](https://codecov.io/gh/pemistahl/lingua-py)\n[![supported languages](https://img.shields.io/badge/supported%20languages-75-green.svg)](#supported-languages)\n[![docs](https://img.shields.io/badge/docs-API-yellowgreen)](https://pemistahl.github.io/lingua-py)\n\n![supported Python versions](https://img.shields.io/badge/Python-%3E%3D%203.7-blue)\n[![pypi](https://img.shields.io/badge/PYPI-v1.0.1-blue)](https://pypi.org/project/lingua-language-detector)\n[![license](https://img.shields.io/badge/license-Apache%202.0-blue.svg)](https://www.apache.org/licenses/LICENSE-2.0)\n\n## 1. What does this library do?\n\nIts task is simple: It tells you which language some provided textual data is\nwritten in. This is very useful as a preprocessing step for linguistic data\nin natural language processing applications such as text classification and\nspell checking. Other use cases, for instance, might include routing e-mails\nto the right geographically located customer service department, based on the\ne-mails\' languages.\n\n## 2. Why does this library exist?\n\nLanguage detection is often done as part of large machine learning frameworks\nor natural language processing applications. In cases where you don\'t need\nthe full-fledged functionality of those systems or don\'t want to learn the\nropes of those, a small flexible library comes in handy.\n\nPython is widely used in natural language processing, so there are a couple\nof comprehensive open source libraries for this task, such as Google\'s\n[*CLD 2*](https://github.com/CLD2Owners/cld2) and\n[*CLD 3*](https://github.com/google/cld3),\n[*langid*](https://github.com/saffsd/langid.py) and\n[*langdetect*](https://github.com/Mimino666/langdetect).\nUnfortunately, except for the last one they have two major drawbacks:\n\n1. Detection only works with quite lengthy text fragments. For very short\n   text snippets such as Twitter messages, they do not provide adequate results.\n2. The more languages take part in the decision process, the less accurate are\n   the detection results.\n\n*Lingua* aims at eliminating these problems. She nearly does not need any\nconfiguration and yields pretty accurate results on both long and short text,\neven on single words and phrases. She draws on both rule-based and statistical\nmethods but does not use any dictionaries of words. She does not need a\nconnection to any external API or service either. Once the library has been\ndownloaded, it can be used completely offline.\n\n## 3. Which languages are supported?\n\nCompared to other language detection libraries, *Lingua\'s* focus is on\n*quality over quantity*, that is, getting detection right for a small set of\nlanguages first before adding new ones. Currently, the following 75 languages\nare supported:\n\n- A\n    - Afrikaans\n    - Albanian\n    - Arabic\n    - Armenian\n    - Azerbaijani\n- B\n    - Basque\n    - Belarusian\n    - Bengali\n    - Norwegian Bokmal\n    - Bosnian\n    - Bulgarian\n- C\n    - Catalan\n    - Chinese\n    - Croatian\n    - Czech\n- D\n    - Danish\n    - Dutch\n- E\n    - English\n    - Esperanto\n    - Estonian\n- F\n    - Finnish\n    - French\n- G\n    - Ganda\n    - Georgian\n    - German\n    - Greek\n    - Gujarati\n- H\n    - Hebrew\n    - Hindi\n    - Hungarian\n- I\n    - Icelandic\n    - Indonesian\n    - Irish\n    - Italian\n- J\n    - Japanese\n- K\n    - Kazakh\n    - Korean\n- L\n    - Latin\n    - Latvian\n    - Lithuanian\n- M\n    - Macedonian\n    - Malay\n    - Maori\n    - Marathi\n    - Mongolian\n- N\n    - Norwegian Nynorsk\n- P\n    - Persian\n    - Polish\n    - Portuguese\n    - Punjabi\n- R\n    - Romanian\n    - Russian\n- S\n    - Serbian\n    - Shona\n    - Slovak\n    - Slovene\n    - Somali\n    - Sotho\n    - Spanish\n    - Swahili\n    - Swedish\n- T\n    - Tagalog\n    - Tamil\n    - Telugu\n    - Thai\n    - Tsonga\n    - Tswana\n    - Turkish\n- U\n    - Ukrainian\n    - Urdu\n- V\n    - Vietnamese\n- W\n    - Welsh\n- X\n    - Xhosa\n- Y\n    - Yoruba\n- Z\n    - Zulu\n\n## 4. How good is it?\n\n*Lingua* is able to report accuracy statistics for some bundled test data\navailable for each supported language. The test data for each language is split\ninto three parts:\n\n1. a list of single words with a minimum length of 5 characters\n2. a list of word pairs with a minimum length of 10 characters\n3. a list of complete grammatical sentences of various lengths\n\nBoth the language models and the test data have been created from separate\ndocuments of the [Wortschatz corpora](https://wortschatz.uni-leipzig.de)\noffered by Leipzig University, Germany. Data crawled from various news websites\nhave been used for training, each corpus comprising one million sentences.\nFor testing, corpora made of arbitrarily chosen websites have been used, each\ncomprising ten thousand sentences. From each test corpus, a random unsorted\nsubset of 1000 single words, 1000 word pairs and 1000 sentences has been\nextracted, respectively.\n\nGiven the generated test data, I have compared the detection results of\n*Lingua*, *langdetect*, *langid*, *CLD 2* and *CLD 3* running over the data of\n*Lingua\'s* supported 75 languages. Languages that are not supported by the other\ndetectors are simply ignored for them during the detection process.\n\nThe box plots below illustrate the distributions of the accuracy values for\neach classifier. The boxes themselves represent the areas which the middle\n50 % of data lie within. Within the colored boxes, the horizontal lines mark\nthe median of the distributions. All these plots demonstrate that *Lingua*\nclearly outperforms its contenders. Bar plots for each language can be found\nin the file\n[ACCURACY_PLOTS.md](https://github.com/pemistahl/lingua-py/blob/main/ACCURACY_PLOTS.md).\nDetailed statistics including mean, median and standard deviation values for\neach language and classifier are available in the file\n[ACCURACY_TABLE.md](https://github.com/pemistahl/lingua-py/blob/main/ACCURACY_TABLE.md).\n\n### 4.1 Single word detection\n\n<br/>\n\n<img src="https://raw.githubusercontent.com/pemistahl/lingua-py/main/images/plots/boxplot-single-words.png" alt="Single Word Detection Performance" />\n\n<br/><br/>\n\n### 4.2 Word pair detection\n\n<br/>\n\n<img src="https://raw.githubusercontent.com/pemistahl/lingua-py/main/images/plots/boxplot-word-pairs.png" alt="Word Pair Detection Performance" />\n\n<br/><br/>\n\n### 4.3 Sentence detection\n\n<br/>\n\n<img src="https://raw.githubusercontent.com/pemistahl/lingua-py/main/images/plots/boxplot-sentences.png" alt="Sentence Detection Performance" />\n\n<br/><br/>\n\n### 4.4 Average detection\n\n<br/>\n\n<img src="https://raw.githubusercontent.com/pemistahl/lingua-py/main/images/plots/boxplot-average.png" alt="Average Detection Performance" />\n\n<br/><br/>\n\n## 5. Why is it better than other libraries?\n\nEvery language detector uses a probabilistic\n[n-gram](https://en.wikipedia.org/wiki/N-gram) model trained on the character\ndistribution in some training corpus. Most libraries only use n-grams of size 3\n(trigrams) which is satisfactory for detecting the language of longer text\nfragments consisting of multiple sentences. For short phrases or single words,\nhowever, trigrams are not enough. The shorter the input text is, the less\nn-grams are available. The probabilities estimated from such few n-grams are not\nreliable. This is why *Lingua* makes use of n-grams of sizes 1 up to 5 which\nresults in much more accurate prediction of the correct language.\n\nA second important difference is that *Lingua* does not only use such a\nstatistical model, but also a rule-based engine. This engine first determines\nthe alphabet of the input text and searches for characters which are unique\nin one or more languages. If exactly one language can be reliably chosen this\nway, the statistical model is not necessary anymore. In any case, the\nrule-based engine filters out languages that do not satisfy the conditions of\nthe input text. Only then, in a second step, the probabilistic n-gram model is\ntaken into consideration. This makes sense because loading less language models\nmeans less memory consumption and better runtime performance.\n\nIn general, it is always a good idea to restrict the set of languages to be\nconsidered in the classification process using the respective api methods.\nIf you know beforehand that certain languages are never to occur in an input\ntext, do not let those take part in the classifcation process. The filtering\nmechanism of the rule-based engine is quite good, however, filtering based on\nyour own knowledge of the input text is always preferable.\n\n## 6. Test report generation\n\nIf you want to reproduce the accuracy results above, you can generate the test\nreports yourself for all classifiers and languages by executing:\n\n    poetry install --extras "langdetect langid gcld3 pycld2"\n    poetry run python3 scripts/accuracy_reporter.py\n\nFor each detector and language, a test report file is then written into\n[`/accuracy-reports`](https://github.com/pemistahl/lingua-py/tree/main/accuracy-reports).\nAs an example, here is the current output of the *Lingua* German report:\n\n```\n##### German #####\n\n>>> Accuracy on average: 89.27%\n\n>> Detection of 1000 single words (average length: 9 chars)\nAccuracy: 74.20%\nErroneously classified as Dutch: 2.30%, Danish: 2.20%, English: 2.20%, Latin: 1.80%, Bokmal: 1.60%, Italian: 1.30%, Basque: 1.20%, Esperanto: 1.20%, French: 1.20%, Swedish: 0.90%, Afrikaans: 0.70%, Finnish: 0.60%, Nynorsk: 0.60%, Portuguese: 0.60%, Yoruba: 0.60%, Sotho: 0.50%, Tsonga: 0.50%, Welsh: 0.50%, Estonian: 0.40%, Irish: 0.40%, Polish: 0.40%, Spanish: 0.40%, Tswana: 0.40%, Albanian: 0.30%, Icelandic: 0.30%, Tagalog: 0.30%, Bosnian: 0.20%, Catalan: 0.20%, Croatian: 0.20%, Indonesian: 0.20%, Lithuanian: 0.20%, Romanian: 0.20%, Swahili: 0.20%, Zulu: 0.20%, Latvian: 0.10%, Malay: 0.10%, Maori: 0.10%, Slovak: 0.10%, Slovene: 0.10%, Somali: 0.10%, Turkish: 0.10%, Xhosa: 0.10%\n\n>> Detection of 1000 word pairs (average length: 18 chars)\nAccuracy: 93.90%\nErroneously classified as Dutch: 0.90%, Latin: 0.90%, English: 0.70%, Swedish: 0.60%, Danish: 0.50%, French: 0.40%, Bokmal: 0.30%, Irish: 0.20%, Tagalog: 0.20%, Tsonga: 0.20%, Afrikaans: 0.10%, Esperanto: 0.10%, Estonian: 0.10%, Finnish: 0.10%, Italian: 0.10%, Maori: 0.10%, Nynorsk: 0.10%, Somali: 0.10%, Swahili: 0.10%, Turkish: 0.10%, Welsh: 0.10%, Zulu: 0.10%\n\n>> Detection of 1000 sentences (average length: 111 chars)\nAccuracy: 99.70%\nErroneously classified as Dutch: 0.20%, Latin: 0.10%\n```\n\n## 7. How to add it to your project?\n\n*Lingua* is available in the [Python Package Index](https://pypi.org/project/lingua-language-detector)\nand can be installed with:\n\n    pip install lingua-language-detector\n\n## 8. How to build?\n\n*Lingua* requires Python >= 3.7 and uses [Poetry](https://python-poetry.org) for packaging and\ndependency management. You need to install it first if you have not done so yet.\nAfterwards, clone the repository and install the project dependencies:\n\n```\ngit clone https://github.com/pemistahl/lingua-py.git\ncd lingua-py\npoetry install\n```\n\nThe library makes uses of type annotations which allow for static type checking with\n[Mypy](http://mypy-lang.org). Run the following command for checking the types:\n\n    poetry run mypy\n\nThe source code is accompanied by an extensive unit test suite. To run the tests, simply say:\n\n    poetry run pytest\n\n## 9. How to use?\n\n### 9.1 Basic usage\n\n```python\n>>> from lingua import Language, LanguageDetectorBuilder\n>>> languages = [Language.ENGLISH, Language.FRENCH, Language.GERMAN, Language.SPANISH]\n>>> detector = LanguageDetectorBuilder.from_languages(*languages).build()\n>>> detector.detect_language_of("languages are awesome")\nLanguage.ENGLISH\n```\n\n### 9.2 Minimum relative distance\n\nBy default, *Lingua* returns the most likely language for a given input text.\nHowever, there are certain words that are spelled the same in more than one\nlanguage. The word *prologue*, for instance, is both a valid English and French\nword. *Lingua* would output either English or French which might be wrong in\nthe given context. For cases like that, it is possible to specify a minimum\nrelative distance that the logarithmized and summed up probabilities for\neach possible language have to satisfy. It can be stated in the following way:\n\n```python\n>>> from lingua import Language, LanguageDetectorBuilder\n>>> languages = [Language.ENGLISH, Language.FRENCH, Language.GERMAN, Language.SPANISH]\n>>> detector = LanguageDetectorBuilder.from_languages(*languages)\\\n.with_minimum_relative_distance(0.25)\\\n.build()\n>>> print(detector.detect_language_of("languages are awesome"))\nNone\n```\n\nBe aware that the distance between the language probabilities is dependent on\nthe length of the input text. The longer the input text, the larger the\ndistance between the languages. So if you want to classify very short text\nphrases, do not set the minimum relative distance too high. Otherwise, `None`\nwill be returned most of the time as in the example above. This is the return\nvalue for cases where language detection is not reliably possible.\n\n### 9.3 Confidence values\n\nKnowing about the most likely language is nice but how reliable is the computed\nlikelihood? And how less likely are the other examined languages in comparison\nto the most likely one? These questions can be answered as well:\n\n```python\n>>> from lingua import Language, LanguageDetectorBuilder\n>>> languages = [Language.ENGLISH, Language.FRENCH, Language.GERMAN, Language.SPANISH]\n>>> detector = LanguageDetectorBuilder.from_languages(*languages).build()\n>>> confidence_values = detector.compute_language_confidence_values("languages are awesome")\n>>> for language, value in confidence_values:\n...     print(f"{language.name}: {value:.2f}")\nENGLISH: 1.00\nFRENCH: 0.79\nGERMAN: 0.75\nSPANISH: 0.70\n```\n\nIn the example above, a list of all possible languages is returned, sorted by\ntheir confidence value in descending order. The values that the detector\ncomputes are part of a **relative** confidence metric, not of an absolute one.\nEach value is a number between 0.0 and 1.0. The most likely language is always\nreturned with value 1.0. All other languages get values assigned which are\nlower than 1.0, denoting how less likely those languages are in comparison to\nthe most likely language.\n\nThe list returned by this method does not necessarily contain all languages\nwhich this LanguageDetector instance was built from. If the rule-based engine\ndecides that a specific language is truly impossible, then it will not be part\nof the returned list. Likewise, if no ngram probabilities can be found within\nthe detector\'s languages for the given input text, the returned list will be\nempty. The confidence value for each language not being part of the returned\nlist is assumed to be 0.0.\n\n## 9.4 Eager loading versus lazy loading\n\nBy default, *Lingua* uses lazy-loading to load only those language models on\ndemand which are considered relevant by the rule-based filter engine. For web\nservices, for instance, it is rather beneficial to preload all language models\ninto memory to avoid unexpected latency while waiting for the service response.\nIf you want to enable the eager-loading mode, you can do it like this:\n\n    LanguageDetectorBuilder.from_all_languages().with_preloaded_language_models().build()\n\nMultiple instances of `LanguageDetector` share the same language models in\nmemory which are accessed asynchronously by the instances.\n\n## 9.5 Methods to build the LanguageDetector\n\nThere might be classification tasks where you know beforehand that your\nlanguage data is definitely not written in Latin, for instance. The detection\naccuracy can become better in such cases if you exclude certain languages from\nthe decision process or just explicitly include relevant languages:\n\n```python\nfrom lingua import LanguageDetectorBuilder, Language, IsoCode639_1, IsoCode639_3\n\n# Including all languages available in the library\n# consumes approximately 3GB of memory and might\n# lead to slow runtime performance.\nLanguageDetectorBuilder.from_all_languages()\n\n# Include only languages that are not yet extinct (= currently excludes Latin).\nLanguageDetectorBuilder.from_all_spoken_languages()\n\n# Include only languages written with Cyrillic script.\nLanguageDetectorBuilder.from_all_languages_with_cyrillic_script()\n\n# Exclude only the Spanish language from the decision algorithm.\nLanguageDetectorBuilder.from_all_languages_without(Language.SPANISH)\n\n# Only decide between English and German.\nLanguageDetectorBuilder.from_languages(Language.ENGLISH, Language.GERMAN)\n\n# Select languages by ISO 639-1 code.\nLanguageDetectorBuilder.from_iso_codes_639_1(IsoCode639_1.EN, IsoCode639_1.DE)\n\n# Select languages by ISO 639-3 code.\nLanguageDetectorBuilder.from_iso_codes_639_3(IsoCode639_3.ENG, IsoCode639_3.DEU)\n```\n\n## 10. What\'s next for version 1.1.0?\n\nTake a look at the [planned issues](https://github.com/pemistahl/lingua-py/milestone/1).\n\n## 11. Contributions\n\nAny contributions to *Lingua* are very much appreciated. Please read the instructions\nin [`CONTRIBUTING.md`](https://github.com/pemistahl/lingua-py/blob/main/CONTRIBUTING.md)\nfor how to add new languages to the library.\n',
    'author': 'Peter M. Stahl',
    'author_email': 'pemistahl@gmail.com',
    'maintainer': None,
    'maintainer_email': None,
    'url': 'https://pemistahl.github.io/lingua-py',
    'packages': packages,
    'package_data': package_data,
    'install_requires': install_requires,
    'python_requires': '>=3.7.1,<4.0.0',
}


setup(**setup_kwargs)
